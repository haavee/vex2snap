#!/usr/bin/env python
# 
# vex2snap -- convert from VEX file to .snp, .prc file, replacing DRUDG
#             for RDBE PFB/DDC + Mark5C/Mark6 [running jive5ab] combo
#
#   Usage:  vex2snap [options] --station XX [vex1 [vex2 [...]]
#           see 'vex2snap --help' for [options]
#
#   Options:
#            --help             show short help
#            --usage            show this built-in help
#            --version          print version and exit succesfully
#            --station          Two-letter station code to generate .prc/.snp for
#            --dest             set destination path for output files
#                               [default: /usr2/sched]
#            --force            overwrite output files [default: don't!]
#            --ignore-utc       do not forget scans from the past
#                               [default: only process scheduled scans
#                               that are still observable - i.e. in the future]
#
#   Description:
#
#   vex2snap reads the vex file(s) and extracts the useful information for the
#   station indicated by XX. It starts by analyzing the scans where this station
#   is in and extracting the necessary setups for those.
#
#   Based on that information a .prc file with initialization and setup
#   procedures is created. A snap file containing the actions for the whole
#   experiment is also output.
#
#        xxx.vex => /usr2/sched/xxx.{prc,snp}  [default output path]
#            Note: if the output file(s) already exist, the program halts.
#                  This behaviour can be overridden through the --force option
#  
#
from __future__ import print_function
import re, os, sys, copy, argparse, itertools, datetime, collections
from functools import reduce, partial
from operator import *
from vex.vex import Vex

##########################################################################################
version = "0.01"


################## These should be standard .... #########################################
compose     = lambda *fns   : (lambda x: reduce(lambda acc, f: f(acc), reversed(fns), x)) # f[0]( f[1]( .. (x) ))
choice      = lambda p, t, f: (lambda x: t(x) if p(x) else f(x))  # branch
ylppa       = lambda x      : (lambda f: f(x))                    # ylppa is 'apply' in reverse ...
combine     = lambda f, *fns: (lambda x: f(*map(ylppa(x), fns)))  # f( fn[0](x), fn[1](x), ... )
method      = lambda f      : (lambda *args, **kwargs: f(*args, **kwargs))
swap_args   = lambda f      : (lambda a, b, *args, **kwargs: f(b, a, *args, **kwargs))
logic_or    = lambda x, y   : x or y                              # operator.__or__ / __and__ are /bitwise/ ops!
logic_and   = lambda x, y   : x and y                             #               ..
const       = lambda x      : (lambda _: x)                       # return the same value irrespective of input
identity    = lambda x      : x                                   # probably the most undervalued operator
between     = lambda a, b   : (lambda x: a<=x<b)                  # missing from module 'operator'?
# our getitem_ always returns a tuple of value(s)
#   for laughs, look up 'operator.itemgetter()' => 3 (three!)
#   different types of return type depending on arguments! FFS!
getitem_    = lambda *n     : (lambda x: tuple(GetN(*n)(x)))#(lambda x: map(x.__getitem__, n)) #compose(tuple, partial(reorder_args(getitem, 1, 0), n))
setitem_    = lambda n, v   : combine(logic_or, partial(reorder_args(setitem, 2, 0, 1), n, v), identity)
# reorder_args: call f with the arguments indicated by idx:
# call f with args[idx[n]] for 0 <= n < len(idx)
# f will be called with len(idx) arguments. can also be used to select/repeat arguments
#reorder_args= lambda f, *idx: (lambda *args, **kwargs: f(*m_itemgetter(*idx)(args), **kwargs))
reorder_args= lambda f, *idx: (lambda *args, **kwargs: f(*getitem_(*idx)(args), **kwargs))
hasattr_    = lambda a      : partial(reorder_args(hasattr, 1, 0), a)
getattr_    = lambda a      : partial(reorder_args(getattr, 1, 0), a)
# it is "setattr(o, a, v)" but we call it as "setattr_(a, v)(o)" thus a,v,o needs to be reorderd to o, a, v, i.e. 2,0,1
# note that setattr_ returns the object itself so it can be chained
setattr_    = lambda a, v   : combine(logic_or, partial(reorder_args(setattr, 2, 0, 1), a, v), identity)
delattr_    = lambda a      : combine(logic_or, partial(reorder_args(delattr, 1, 0), a), identity)
Map         = lambda f      : partial(map, f)
StarMap     = lambda f      : partial(itertools.starmap, f)
Pam         = lambda *fns   : (lambda x: map(lambda f: f(x), fns))
Filter      = lambda f      : partial(filter, f)
Reduce      = lambda f, *a  : partial(reduce, f, *a)
Sorted      = lambda **kws  : partial(sorted, **kws)
GroupBy     = lambda f      : (lambda l: itertools.groupby(l, f))
Zip         = lambda l      : (lambda x: zip(l,x))
XformItem   = lambda n, f   : (lambda o: setitem_(n, f(o[n])))
Type        = lambda **kwargs  : type('', (), kwargs)
all_equal   = compose(lambda g: next(g, True) and not next(g, False), itertools.groupby)
is_none     = partial(is_, None)
GetN        = itemgetter
GetA        = attrgetter
Call        = methodcaller
# head, tail on lists might be useful!
head        = GetN(0)
tail        = GetN(slice(1,None))

def Raise(x):
    raise x
def Error(f):
    def do_it(x):
        raise RuntimeError(f(x))
    return do_it
Assert  = lambda x, *args, **kwargs: Raise(AssertionError(*args, **kwargs)) if not x else None
AssertF = lambda f, *args, **kwargs: (lambda x: Assert(f(x), *args, **kwargs))

def MSG(pfx = None):
    fmt = ("{0}" if pfx is None else pfx+": {0}").format
    def print_it(x):
        print(fmt(x))
        return x
    return print_it

# filterWith - a filter that acts as "sorted(..., key=fn)
# i.e. filter input based on a predicate on item in stead of on the item
def filterWith(predicate):
    def do_filter(inp):
        result = []
        for item in inp:
            predicate(item) and result.append( item )
        return result
    return do_filter

# this implementation is not the shortest partition() but it is the fastest
#  (pred, list) => (true_list, false_list)
def partition(pred, l):
    ltrue, lfalse = (list(), list())
    for item in l:
        (ltrue if pred(item) else lfalse).append( item )
    return (ltrue, lfalse)
Partition = lambda pred: (lambda l: partition(pred, l))


###################################################
#       Some time-related functionality
###################################################

# convert any sequence of (doy, hh, mm, ss) into seconds-within-year
yhms2sec    = compose(sum, StarMap(mul), Zip([86400, 3600, 60, 1]), Map(int))
# extract those values from an utctimetuple()
utsec_year  = compose(yhms2sec, GetA('tm_yday', 'tm_hour', 'tm_min', 'tm_sec'), Call('utctimetuple'))
# extract them from a VEX time stamp 
vextime2sec = compose(yhms2sec, Call('groups'), re.compile(r"^\d+y(\d+)d(\d+)h(\d+)m(\d+)s$").match,
                      partial(re.sub, r"[ \t\n]*", r""))
utcsec_now  = utsec_year( datetime.datetime.utcnow() )


#############################################################################
#
#                      Commandline parsing
#
#############################################################################
class PrintHelp(argparse.Action):
    def __call__(self, the_parsert, *args):
        the_parsert.print_help() or sys.exit( 0 )

arg0_or_zero = choice(truth, itemgetter(0), const(0))
def usage(*args):
    # http://stackoverflow.com/a/1676860
    import pydoc, inspect
    # extract the documentation at the top of this module, put it through pydoc.pager and then exit :-)
    return compose(const(arg0_or_zero(args)), pydoc.pager, inspect.getcomments, itemgetter(__name__))(sys.modules)

class PrintUsage(argparse.Action):
    def __call__(self, the_parsert, *args):
        sys.exit( usage() )


parsert = argparse.ArgumentParser(description="Transform VEX files to .snp/.prc", add_help=False)
parsert.add_argument('--help',   nargs=0, action=PrintHelp, help="Show this help message and exit succesfully")
parsert.add_argument('--usage',  nargs=0, action=PrintUsage, help="Show built-in usage")
parsert.add_argument('--debug',  dest='debug', action='store_true', default=False, 
                     help="Print debugging information")
parsert.add_argument('--version', action='version', version=version, help="Print current version and exit succesfully")
parsert.add_argument('--dest', dest='output_path', type=str, default="/usr2/sched",
                     help="Location where to store output .prc/.snp files")
parsert.add_argument('--force', dest='file_exists', action="store_const", const=const(False), default=os.path.isfile,
                     help="Overwrite existing output files (default: don't)")
parsert.add_argument('--station', dest='station', type=str, required=True,
                     help="The station two-letter-codefor which to generate the .prc/.snp files")
parsert.add_argument('--ignore-utc', dest="utc_limit", default=utcsec_now, action="store_const", const=0,
                     help="Ignore current UTC time - i.e. just process all scans even when they cannot be observed anymore")
parsert.add_argument("vexfile", nargs='*', help="One or more vexfiles to process")

###################################
# Actually parse the command line #
###################################
userinput = parsert.parse_args()

# Take some actions based on what the user gave us (debug e.g.)
if userinput.debug:
    D  = MSG("DEBUG")
    DD = lambda y: MSG(y)
else:
    D  = identity
    DD = const(identity)
    def silent_except_hook(tp, val, tb):
        print(str(val))
    sys.excepthook = silent_except_hook

#################################################################################################
#
#                 Handle a single vex file
#
#################################################################################################
fileExists = choice(os.path.isfile, identity, compose(Raise, RuntimeError, partial(add, "File does not exist: ")))

# transform /path/to/file.vex => file
#  .split() => (/path/to, file.vex)
#  .splitext() => (file, vex)
vexName    = compose(GetN(0), os.path.splitext, GetN(1), os.path.split)

# input: vexfile name, output: functions generating the names of the output file(s) given a station
fn_func      = lambda ext: (lambda base: compose("{0}{{0}}.{1}".format(base.lower(), ext.lower()).format, str.lower))
add_prefix   = partial(os.path.join, userinput.output_path)
output_files = lambda vexobj, station: compose(DD("Output files"), Map(compose(add_prefix, ylppa(station))),
                                               Pam(*map(fn_func, ['snp', 'prc', 'lst'])),
                                               str.lower, next, Call('iterkeys'), GetN('EXPER'))(vexobj)

# Filter the given list-of-files using userinput.file_exists. Non-empty list raises an error.
ok_to_write  = compose(choice(truth,
                              compose(Raise, RuntimeError, "Output file(s) {0} exist. Use --force to forcibly overwrite".format),
                              identity),
                       list, Filter(userinput.file_exists))


###############################################################################
#
#                      Dealing with vex content
#
###############################################################################

# wrapper to turn opening a vex file into a context so 
# this works: 
#    with OpenVex(filename) as vexf: 
#        <stuff with vexf>
class OpenVex(object):
    def __init__(self, filename):
        self.filename = filename
    def __enter__(self):
        self.vex = Vex(self.filename)
        return self.vex
    def __exit__(self, e, t, f):
        return

vexyear     = compose(GetN(0), Map(int), Call('groups'),
                      re.compile(r"^(\d+)y\d+d\d+h\d+m\d+s$").match, partial(re.sub, r"[ \t\n]*", r""))

def s2v_r(acc, x):
    (whole, remain) = divmod(acc.time, x[0])
    acc.time_s     += x[1](whole)
    acc.time        = remain
    return acc
sec2vextime = compose(GetA('time_s'), AssertF(compose(not_, GetA('time')), "Non-integer second time stamp is unacceptable"),
                      Reduce(s2v_r, [(86400, "{0}d".format), (3600, "{0:02d}h".format),
                                     (60, "{0:02d}m".format), (1, "{0:02d}s".format)]),
                      lambda x: Type(time_s="", time=x))
intSec      = compose(int, str.strip, partial(re.sub, r"s(ec)?", r""))


class Scan(object):
    __slots__ = ['mode', 'label', 'nominal_start', 'source', 'offset', 'duration', 'year']

    # initialize from keywordargs
    def __init__(self, **kwargs):
        reduce(lambda acc, attr: setattr(acc, attr, kwargs.pop(attr, None)) or acc, Scan.__slots__, self)
        Assert(self.duration>self.offset, "Attempt to observe scan where data-good > scan duration")

    @property
    def start(self):
        return self.nominal_start + self.offset
    @property
    def end(self):
        return self.nominal_start + self.duration


def station_scan(station):
    # scan == (scanId, <vex scan obj>)
    def station_observes(scan):
        (scanId, scanObj) = scan
        #station=Eb:    0 sec:  620 sec:   42.961 GB:   :       : 0;
        #        0      1       2          3               4      5
        station_line      = filter(compose(partial(eq, station), GetN(0)), scanObj.getall('station'))
        station_line      = station_line[0] if station_line else None
        if not station_line:
            return None
        return Scan(mode=scanObj['mode'], nominal_start=vextime2sec(scanObj['start']),
                    source=scanObj['source'], offset=intSec(station_line[1]), label=scanId,
                    year=vexyear(scanObj['start']), duration=intSec(station_line[2]))
    return station_observes

# Filter the list of scans for the indicated station and also
# filter out the ones that are in the past
end_in_future     = compose(partial(lt, userinput.utc_limit), DD("scan-end"), GetA('end'))
get_station_scans = lambda station: compose(Filter(end_in_future), Filter(truth), Map(station_scan(station)), Call('iteritems'), GetN('SCHED'))

# From a MODE extract the IF, FREQ, BBC, TRACKS, PHASE_CAL_DETECT for the requested station.
# In the VEX file these are ref lines so format is:
#   ref $REF = <defname> : station : station : ... ;
#   ref $REF = <defname> : station : station : ... ;
#
#   mode.iteritems() gives us a sequence of:
#      [ (REF-name, [<defname>, station, station, ...]),
#        (REF-name, [<defname>, station, station, ...], .. ]
# So we filter the required REF-name's that we need, keeping only the entry
# where the requested station is in the list of stations following the <defname>.
# 
# Eventually we produce a dict with entries like this:
#       {"mode": ("setupXX", <mode-for-station>)}
# 
#  where <mode-for-station> == { 'BBC': "defname>, 'IF': "defname", ... }


# extract <vexfile>['MODE'][mode] <object> and set <object>.mode = "mode"
get_mode         = lambda vexobject: lambda mode: compose(setattr_('mode', mode), GetN(mode), GetN('MODE'))(vexobject)
# set <mode object>.setup = "setupXX", auto-counting from 1
enumerate_setups = lambda mode, cnt=itertools.count(1): setattr_('setup', "setup{0:02d}".format(next(cnt)))(mode)
# Which ref lines we need and how to tell which one applies to a particular station
needed_refs      = set(['IF', 'FREQ', 'BBC', 'TRACKS', 'PHASE_CAL_DETECT'])
is_for_station   = lambda station  : lambda l: l[0] if station in l[1:] else None
refs_for_station = lambda st, modes: reduce(lambda acc, mode:
                                     acc.update( {mode.mode:(mode.setup,
                                                             compose(dict, Map(compose(tuple, Pam(GetN(0), compose(GetN(0), GetN(1))))),
                                                                     Filter(compose(is_for_station(st), GetN(1))),
                                                                     Filter(compose(needed_refs.__contains__, GetN(0))),
                                                                     list, Call('iteritems'))(mode)) } ) or acc, modes, dict())

###############################################################################
##    moving on to decoding
###############################################################################

mk_vex_lut = lambda sect, defname, key:compose(DD("VEX lut[{0}.{1}".format(sect,defname)), dict, Map(Pam(head, tail)),
                                               Call('getall', key), GetN(defname), GetN(sect))

# shorthands for converting vex file values to canonical things
fltMHz     = choice(truth, compose(float, str.strip, partial(re.compile(r'[ \t]*MHz').sub, "")), const(None))
sideband_  = { 'U': 'usb', 'L': 'lsb' }
canon_sb   = compose(sideband_.__getitem__, str.upper)
canon_pol  = str.lower
canon_if   = str.lower
pcal_state = choice(is_none, const("pcaloff"), const("pcalon"))
canon_pcal = choice(is_none, const("off"), int)
# there is a mapping of IF_A/B => input 0 and C/D to 1
inp_zero   = "AaBb"
inp_one    = "CcDd"
if_to_inp  = choice(inp_zero.__contains__, const(0),
                    choice(inp_one.__contains__, const(1),
                           Error("No known mapping for IF{0} to RDBE input".format)))

pfb_split  = compose(enumerate, Filter(truth), Partition(lambda x: x.sb == 'lsb'))
# group list of channels by their IF and return [(IF, <channels>), ...]
# Note: groupby() returns tuples with (key, <iterable>) but the <iterable> can be
#       used only once. So we transform that into a list
if_key     = GetA('abcd')
split_by_if= compose(Map(lambda t: (t[0], list(t[1]))), GroupBy(if_key), Sorted(key=if_key))
# given list of CHxx channel refs, sort numerically by xx
int_key    = lambda *args: compose(int, Call('group', 1), re.compile(*args).match)
int_sorted = lambda *args: Sorted(key=int_key(*args))
#chet's 'upper edge' table, modified to add 1024, leave out 528
# (verbatim from vex2snap.pl)
chet_fh    = [1024,1008,976,944,912,880,848,816,784,752,720,688,656,624,592,560];
lookup_fh  = choice(chet_fh.__contains__, chet_fh.index, Error("Unmapped PFB channel frequency {0}".format))

inputs     = lambda: (itertools.product( ["dbe0", "dbe1"], range(2) ))
concat     = Reduce(add)          # input: iterable-of-lists, output one list

# Post-process the iochannel assignments
def mk_ioch_(acc, item):
    # item = (dbe, <dict>)
    dbe, ch_dict = item
    cmd = "rdbe_cmd="+dbe+",5,dbe_ioch_assign=";
    # loop over the channels in vex order because that's
    # how they need to be written?
    for ch in sorted(ch_dict.iterkeys(), key=int_key("^CH(\d+)")):
        cmd += "{0}:{1}::".format( *ch_dict[ch] )
    cmd += ";"
    return acc.append( cmd ) or acc
mk_ioch = lambda l: reduce(mk_ioch_, l, list())


###############################################################################
#
#  Process the channels based on deduced type of firmware
#  and generate the RDBE procedure
#
###############################################################################
def fqlist_pfb(channels):
    # put all channels of one kind of sideband in one DBE, filter out
    # ones that don't have channels and enumerate the resulting channel lists
    dbes, fqs      = (list(), list())
    los, rdbe_los  = (dict(), dict())
    clrs           = collections.defaultdict(list)
    # Keep a mapping of DBE => [CHref => (inp, ch)] in order to be able 
    # to generate the correct "dbe_ioch_assign" command
    iochs          = collections.defaultdict(dict)   # map (CHref) => (inp, ch)
    pcal_s         = set()    # set of pcal states, can assert we only have one
    rdbe_inp       = inputs() # allow us to loop over all inputs
    
    for IF, ch_list in split_by_if(channels):
        # we could split it up in chunks of 16 channels and route the same IF
        # to multiple RDBE inputs but for now we don't
        Assert(len(ch_list)<=16, "Cannot do more than 16 channels per RDBE IF input")

        # assign those channels to the next available input
        (dbe, inp) = next(rdbe_inp)
        if dbe not in clrs:
            #clrs[dbe].append( "rdbe_person={dbe},pfb".format(dbe=dbe) )
            clrs[dbe].append( "rdbe_cmd={dbe},50,dbe_personality=pfbg:pfbg_1_4.bin".format(dbe=dbe) )
            clrs[dbe].append( "rdbefclr={dbe}".format(dbe=dbe) )
        # count channels per IF
        for (chan, ch) in enumerate(ch_list, start=1):
            # convert channel properties to stuff we need
            ch_frq = int(ch.freq - ch.lo)
            iif    = if_to_inp(ch.abcd)
            ich    = lookup_fh(abs(ch_frq))  # look up channel freq in table to find index
            # Get current pcal state
            pcal_s.add( pcal_state(ch.pcal) )
            # did we set the LO for this (IF,input)?
            loc    = "lo{0}".format( ch.abcd.lower() )
            if (loc, iif) not in los:
                los[(loc, iif)]      = "lo="+loc+",{ch.lo:.2f},{ch.sb},{ch.pol}cp,{pcal}".format(ch=ch, pcal=canon_pcal(ch.pcal))
                rdbe_los[(loc, iif)] = "rdbe_if="+loc+",{ch.lo:.2f},{ch.sb},{ch.pol}cp,{dbe},if{iif}".format(ch=ch, dbe=dbe, iif=iif)
            # Append a line describing this channel
            fqs.append( "rdbef{chan:02d}={dbe},if{iif},{ch.freq:.2f},{ch.bw},{ch.sb},{ch.pol},{ich}".format(
                        dbe=dbe, chan=ch.bbc, iif=iif, ch=ch, ich=ich) )
            # Put it in the ioch mappings
            iochs[ dbe ][ ch.ch_ref ]= (iif, ich)

    # assert there's only one pcal state
    Assert(len(pcal_s)==1, "Inconsistent PCAL states - more than one found")
    # concatenate all commands - take care of re-ordering the "rdbefXX" commands by XX
    return los.values() + concat(clrs.values())+sorted(fqs, key=int_key(r"^rdbef(\d+)", re.I)) + \
           rdbe_los.values() + mk_ioch(iochs.iteritems())

# distribute the DDC channels over the RDBE inputs 
# according to vex2snap.pl
#   if dual pol 8 channel, send R to dbe0 and L to dbe1
# otherwise assign ch 0-3 to DBE0, 4-7 to DBE1
pol_key      = GetA('pol')
split_by_pol = compose(Map(lambda t: (t[0], list(t[1]))), GroupBy(pol_key), Sorted(key=pol_key))
# given: list of [(pol, [channels]), (pol, [channels])]
# return:  (dual-pol <bool>, total-nr-channels <int>, each-pol-same-nr-channels <bool>)
#check_dual_p = compose(Pam(compose(partial(eq, 2), len), sum, all_equal, compose(max, Map(len))), Map(GetN(1)))
check_dual_p = compose(Pam(compose(partial(eq, 2), len), sum, all_equal, max), Map(compose(len, GetN(1))))
ddc_channels = lambda: (itertools.product( ["dbe0", "dbe1"], range(4) ))
invert_sb_   = {'l':'u', 'lsb':'usb', 'u':'l', 'usb':'lsb'}
invert_sb    = compose(choice(invert_sb_.__contains__, invert_sb_.__getitem__, Error("Unknown sideband {0}".format)), str.lower) 

# RDBE setting up DownConverters is tricky, must be first match in the tables
# for upper side band           DDS freq       M  S  [M=Mode S=Sub]
usb_table    =[ lambda fq, bw:  (fq-512+bw/2,  1, 2) if fq<=(640-bw)   else None
              , lambda fq, bw:  (768-fq-bw/2,  0, 1) if fq<=(768-bw)   else None
              , lambda fq, bw:  (768-fq-bw/2,  0, 1) if fq<=(768-bw/2) else None
              , lambda fq, bw:  (fq+bw/2-768,  1, 1) if fq< (768)      else None
              , lambda fq, bw:  (fq-768+bw/2,  1, 1) if fq<=(896-bw)   else None
              , lambda fq, bw:  (1024-fq-bw/2, 0, 0) if fq<=(1024-bw)  else None]
# for lower side band           DDS freq       M  S  [M=Mode S=Sub]
lsb_table    =[ lambda fq, bw:  (1024-fq+bw/2, 1, 0) if fq>=(896+bw)   else None
              , lambda fq, bw:  (fq-768-bw/2,  0, 3) if fq>=(768+bw)   else None
              , lambda fq, bw:  (fq-768-bw/2,  0, 3) if fq>=(768+bw/2) else None
              , lambda fq, bw:  (768-fq+bw/2,  1, 3) if fq>=(768)      else None
              , lambda fq, bw:  (768-fq+bw/2,  1, 3) if fq>=(640+bw)   else None
              , lambda fq, bw:  (fq-512-bw/2,  0, 2) if fq>=(512+bw)   else None]

get_dds_cfg = lambda sb, fq, bw: compose(next, partial(itertools.dropwhile, is_none),
                                         Map(lambda f: f(fq, bw)))(usb_table if sb in ['u', 'usb'] else lsb_table)

# input: dict of {<dc#> : <phys inpt>, ... }
# produce string "<phys inp>:<phy inp>:<phys inp>" sorted by <dc#>
mk_xbar_ = lambda tbl: "dbe_xbar="+":".join( getitem_(*sorted(tbl.keys()))(tbl) )
# input: dict of { dbe : dc#-to-phys-input-mapping }
# output: list of [ "rdbe_cmd=dbe0,3,dbe_xbar=3:3:3:2:2:2:2:2;", ... ]
#mk_xbar  = compose(Map(lambda item: ""+mk_xbar(item[1], Call('iteritems'))
mk_xbar  = compose(Map(compose(Reduce(add), Pam(compose("rdbe_cmd={0},3".format, GetN(0)), compose(mk_xbar_, GetN(1))))), Call('iteritems'))

def fqlist_ddc(channels):
    # put all channels of one kind of sideband in one DBE, filter out
    # ones that don't have channels and enumerate the resulting channel lists
    dbes, fqs, dcs = (list(), list(), list())
    los, rdbe_los  = (dict(), dict())
    clrs           = collections.defaultdict(list)
    # Keep a mapping of DBE => [CHref => (inp, ch)] in order to be able 
    # to generate the correct "dbe_ioch_assign" command
    iochs          = collections.defaultdict(dict)   # map (CHref) => (inp, ch)
    pcal_s         = set()    # set of pcal states, can assert we only have one
    dbes_used      = set()
    xbar           = collections.defaultdict(dict)
   
    # get list: [ (pol, [channels]), (pol, [channels]), ...]
    chans_by_pol   = split_by_pol(channels)
    # for dual pol dual rdbe we require: total nr of channels > 4 and #-right-pol == #-left-pol
    (dual_pol, n_chan_tot, same_nch_pol, max_chan_pol) = check_dual_p( chans_by_pol )
    Assert(n_chan_tot<=8, "DDC mode cannot support {0} channels, it is limited to <=8".format(n_chan_tot))
    # this constraint could be different between how flexible IFs can be routed to RDBE inputs
    Assert(max_chan_pol<=4, "DDC mode cannot support {0} channels / polarization, it is limited to <=4".format(max_chan_pol))

    if dual_pol and same_nch_pol and n_chan_tot>4:
        # dual pol > 4 channels, assign each pol to one DBE 'r' => 0, 'l' => 1
        for pol, ch_list in chans_by_pol:
            dbe = "dbe0" if pol == 'r' else "dbe1"
            dbes_used.add( dbe )
            # send all channels to this DBE
            for ich, ch in enumerate(ch_list):
                # convert channel properties to stuff we need
                ch_frq = int(ch.freq - ch.lo)
                iif    = if_to_inp(ch.abcd)
                # Get current pcal state
                pcal_s.add( pcal_state(ch.pcal) )
                # did we set the LO for this (IF,input)?
                loc    = "lo{ch.canon_if}".format( **locals() )
                if (loc, iif) not in los:
                    los[(loc, iif)]      = "lo="+loc+",{ch.lo:.2f},{ch.sb},{ch.pol}cp,{ch.canon_pcal}".format(**locals())
                    rdbe_los[(loc, iif)] = "rdbe_if="+loc+",{ch.lo:.2f},{ch.sb},{ch.pol}cp,{dbe},if{iif}".format(**locals())
                # Append a line describing this channel
                fqs.append( "rdbef{ch.bbc:02d}={dbe},if{iif},{ch.freq:.2f},{ch.bw},{ch.sb},{ch.pol},{ich}".format(**locals()) )
                # configure the downconverter
                #  the decimation
                decimation, rem = divmod(128, ch.bw)
                Assert(rem==0, "Channel bandwidth {0} not supported by DDC".format(ch.bw))
                # check for lower/upper side band
                sb = copy.deepcopy(ch.sb)
                if ch_frq<0:
                    ch_frq = -ch_frq
                    sb     = invert_sb(sb)
                # Get the downconverter config
                (dds_freq, mode, sub) = get_dds_cfg(sb, ch_frq, ch.bw)
                dcs.append( "rdbe_dc_cfg={dbe},{ich}:{decimation}:{dds_freq:.2f}:{mode};".format(**locals()) )
                # and the xbar
                xbar[ dbe ][ ich ] = sub + iif*4
                
                # Put it in the ioch mappings
                #iochs[ dbe ][ ch.ch_ref ]= (iif, ich)
    else:
        # just break up the channels in groups of 4
        available_channels = ddc_channels()
        for ch in channels:
            (dbe, ich) = next(available_channels)
            dbes_used.add( dbe )
            # convert channel properties to stuff we need
            ch_frq = int(ch.freq - ch.lo)
            iif    = if_to_inp(ch.abcd)
            # Get current pcal state
            pcal_s.add( pcal_state(ch.pcal) )
            # did we set the LO for this (IF,input)?
            loc    = "lo{0}".format( ch.abcd.lower() )
            if (loc, iif) not in los:
                los[(loc, iif)]      = "lo="+loc+",{ch.lo:.2f},{ch.sb},{ch.pol}cp,{pcal}".format(ch=ch, pcal=canon_pcal(ch.pcal))
                rdbe_los[(loc, iif)] = "rdbe_if="+loc+",{ch.lo:.2f},{ch.sb},{ch.pol}cp,{dbe},if{iif}".format(ch=ch, dbe=dbe, iif=iif)
            # Append a line describing this channel
            fqs.append( "rdbef{chan:02d}={dbe},if{iif},{ch.freq:.2f},{ch.bw},{ch.sb},{ch.pol},{ich}".format(
                        dbe=dbe, chan=ch.bbc, iif=iif, ch=ch, ich=ich) )
            (dds_freq, mode, sub) = get_dds_cfg(sb, ch_frq, ch.bw)
            dcs.append( "rdbe_dc_cfg={dbe}:{ich}:{decimation}:{fq:.2f}:{mode};".format(dbe=dbe, ich=ich,
                              decimation=decimation, fq=fq, mode=mode) )
            # and the xbar
            xbar[ dbe ][ ich ] = sub + iif*4
            # Put it in the ioch mappings
            #iochs[ dbe ][ ch.ch_ref ]= (iif, ich)

    # add commands to load personality and clear
    for dbe in dbes_used:
        #clrs[dbe].append( "rdbe_person={dbe},ddc,".format(dbe=dbe) )
        clrs[dbe].append( "rdbe_cmd={dbe},50,dbe_personality=ddc:ddc_1601583.bin".format(dbe=dbe) )
        clrs[dbe].append( "rdbefclr={dbe}".format(dbe=dbe) )

    # Construct the crossbar command(s)
    

    # assert there's only one pcal state
    Assert(len(pcal_s)==1, "Inconsistent PCAL states - more than one found")
    return los.values() + concat(clrs.values()) + sorted(fqs, key=int_key(r"^rdbef(\d+)", re.I)) +\
           rdbe_los.values() + dcs + mk_ioch(iochs.iteritems())


# lookup table
fqlist_fn   = {'PFB': fqlist_pfb, 'DDC4': fqlist_ddc, 'DDC8': fqlist_ddc }
make_fqlist = choice(fqlist_fn.__contains__, fqlist_fn.__getitem__, 
                     compose(Raise, RuntimeError, "No make_fqlist for firmware {0}".format))


#################################################
# describe a setup from the VEX file
#################################################
class Setup(object):
    __slots__ = ['setup', 'mode', 'channels', 'track_frame_format']

    def __init__(self, **kwargs):
        reduce(lambda acc, attr: setattr(acc, attr, kwargs.pop(attr, None)) or acc, Setup.__slots__, self)

    def __repr__(self):
        return "Setup: {0.setup} [{0.mode}] {0.datarate}Mbps {0.track_frame_format} ".format(self) + self.firmware + \
               "\n\t".join([""]+map(repr, [] if not self.channels else self.channels))

    @property
    def firmware(self):
        if self.channels is None:
            return None
        return "PFB" if len(self.channels)>8 else ("DDC4" if len(self.channels)<=4 else "DDC8")

    @property
    def datarate(self):
        # sum all bandwidths (units in MHz), multiply by 2 on account of Nyquist
        return 2 * int(sum(map(GetA('bw'), [] if self.channels is None else self.channels)))

    @property
    def procedure(self):
        Assert(self.channels is not None, "No channels defined for setup {0}".format(self.setup))
        # generate the procedure text
        return Procedure(self.setup, make_fqlist(self.firmware)(self.channels))


class Channel(object):
    __slots__ = ['bbc', 'abcd', 'pol', 'lo', 'sb', 'pcal', 'bw', 'freq', 'ch_ref']

    def __init__(self, **kwargs):
        reduce(lambda acc, attr: setattr(acc, attr, kwargs.pop(attr, None)) or acc, Channel.__slots__, self)

    @property
    def canon_pcal(self):
        return canon_pcal(self.pcal)
    @property
    def canon_sb(self):
        return canon_sb(self.sb)
    @property
    def canon_if(self):
        return canon_if(self.abcd)
    @property
    def canon_pol(self):
        return canon_pol(self.pol)
    @property
    def pcal_state(self):
        return pcal_state(self.pcal)

    __repr__ = method("BBC{0.bbc:02d}: {0.bw:.2f}MHz@{0.freq:.2f} [LO={0.lo:.2f}MHz] {0.sb}{0.pol} pcal:{0.pcal}".format)


####################################################
#  A snap procedure
####################################################
class Procedure(object):
    def __init__(self, name, init_list=None):
        # at most 12 characters in procedure name
        Assert(len(name)<=12, "SNAP procedure name '{0}' is longer than 12 characters".format(name))
        self.name  = name
        self.lines = copy.deepcopy(init_list if init_list is not None else list())

    def append(self, line):
        self.lines.append(line)
        return self

    def __str__(self):
        return "\ndefine  {0: <12s} 00000000000x\n".format(self.name) + "\n".join(self.lines)+"\nenddef"

# input: - ("mode", ("setupXX", { 'BBC': "BBC-def", 'IF': "IF-def", ... ) 
#        - vex object
# transform to:
#          ("mode", Object(setup="setupXX", procedure="define setupXX 0000000x\n .... enddef\n", firmware="..."))
def resolve_mode(vexobj):
    def do_resolve(acc, mode):
        # destructure the mode "(key, value)" item, where value = "(setup, {})"
        (modename, (setupname, setup)) = mode

        # Transform the BBC_assign entries into lookuptable {BBCref: (BBCnum, IFref), ...}
        bbc_lut = mk_vex_lut('BBC', setup['BBC'], 'BBC_assign')(vexobj)
        if_lut  = mk_vex_lut('IF' , setup['IF'] , 'if_def')(vexobj)

        # Can already construct the actual setup object
        nSetup = Setup(mode=modename, setup=setupname, channels=list(),
                       track_frame_format=vexobj['TRACKS'][setup['TRACKS']]['track_frame_format'])

        # Loop over all defined frequency channels, collect important frequency, lo info
        for fqchan in vexobj['FREQ'][setup['FREQ']].getall('chan_def'):
            (_, ch_freq, sb, bw, ch_ref, bbc_ref, nix) = fqchan
            (bbc_num, if_ref)                     = bbc_lut[ bbc_ref ]
            (ABCD, if_pol, if_lo, if_sb, if_pcal) = if_lut[ if_ref ]
            nSetup.channels.append( Channel(bbc=int(bbc_num), abcd=ABCD, pol=canon_pol(if_pol), lo=fltMHz(if_lo), ch_ref=ch_ref,
                                           sb=canon_sb(if_sb), pcal=fltMHz(if_pcal), bw=int(fltMHz(bw)), freq=fltMHz(ch_freq)) )
                      
        print(nSetup.procedure)
        #
    return do_resolve

#############################################################
#        do the work of processing the vex file
#############################################################
def process_vex(vexfile):
    with OpenVex(vexfile) as vexf:
        # Generate the output file names: destination/<exper><station>.{prc, snp, lst}
        files = output_files(vexf, userinput.station)
        # check if they exist and if so if ok to overwrite
        ok_to_write(files)

        # figure out which scans the station should observe
        # we do not extract the scan object(s) from the vexfile yet because
        # we need to retain the order of the scans (if we created a dict { "scanLabel":<scanObject> }
        # we could loose the order of scan label. There is no guarantee scan labels contain any useful information.
        #scans = filter(station_scan(userinput.station), vexf['SCHED'].iteritems())
        scans = get_station_scans(userinput.station)( vexf )

        Assert(scans, "The station '{0}' does not observe any of the scans".format(userinput.station))

        # collect all mode names - they need to be converted into setups
        modes = compose(set, Map(GetA('mode')))(scans)
        #modes = reduce(lambda acc, scan: acc.add(scan_mode(scan)) or acc, scans, set())

        # Convert to a dict of {"mode", ("setupXX", {'BBC': <BBC-defname>, 'IF': <IF-defname>, ..}), ... }
        # with the defnames applicable to the desired names
        modes = compose(partial(refs_for_station, userinput.station), Map(enumerate_setups), Map(get_mode(vexf)))(modes)

        setups = reduce(resolve_mode(vexf), modes.iteritems(), {})

        procedure = Procedure("sched_")
        procedure.append('" BP229B EB_RDBE2 Eb')

        print("Scans: ", Map(GetA('label'))(scans))
        print("Modes: ", modes)
        print("Procedures:")
        print(procedure)
    return None

# main loop: iterate over all command line arguments
main = compose(process_vex, MSG("Start processing"))

map(main, userinput.vexfile)
