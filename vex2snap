#!/usr/bin/env python
# 
# vex2snap -- convert from VEX file to .snp, .prc file, replacing DRUDG
#             for RDBE PFB/DDC + Mark5C/Mark6 [running jive5ab] combo
#
#   Usage:  vex2snap [options] --station XX [vex1 [vex2 [...]]
#           see 'vex2snap --help' for [options]
#
#   Options:
#            --help             show short help
#            --usage            show this built-in help
#            -v, --version      print version and exit succesfully
#            --station          Two-letter station code to generate .prc/.snp for
#            --dest             set destination path for output files
#                               [default: /usr2/sched]
#            --recorder TYPE[:DISKS] Override scheduled recorder from VEX file
#                               By default vex2snap will use the recorder defined
#                               in the VEX file for the selected station. Override
#                               by using this option.
#                               TYPE  = Mark5C | Mark6 | none
#                               DISKS = (only if TYPE=Mark6)
#                                       argument to "set_disks=", specify on which  
#                                       disks or module to record the experiment
#                                       [default for Mark6: "mark6" -
#                                        i.e. all presently mounted disks]
#            --force            overwrite output files [default: don't!]
#            --ignore-utc       do not forget scans from the past
#                               [default: only process scheduled scans
#                               that are still observable - i.e. in the future]
#
#   Description:
#
#   vex2snap reads the vex file(s) and extracts the useful information for the
#   station indicated by XX. Setups are generated for all modes found for station XX.
#
#   Based on that information a .prc file with initialization and setup
#   procedures is created. A snap file containing the actions for the whole
#   experiment is also output.
#
#        xxx.vex => /usr2/sched/xxx.{prc,snp}  [default output path]
#            Note: if the output file(s) already exist, the program halts.
#                  This behaviour can be overridden through the --force option
#  
#
from __future__ import print_function
import re, os, sys, copy, time, argparse, itertools, datetime, collections
from functools import reduce, partial
from operator import *
from vex.vex import Vex

##########################################################################################
version = "0.01"


################## These should be standard .... #########################################
compose     = lambda *fns   : (lambda x: reduce(lambda acc, f: f(acc), reversed(fns), x)) # f[0]( f[1]( .. (x) ))
choice      = lambda p, t, f: (lambda x: t(x) if p(x) else f(x))  # branch
ylppa       = lambda x      : (lambda f: f(x))                    # ylppa is 'apply' in reverse ...
combine     = lambda f, *fns: (lambda x: f(*map(ylppa(x), fns)))  # f( fn[0](x), fn[1](x), ... )
method      = lambda f      : (lambda *args, **kwargs: f(*args, **kwargs))
swap_args   = lambda f      : (lambda a, b, *args, **kwargs: f(b, a, *args, **kwargs))
logic_or    = lambda x, y   : x or y                              # operator.__or__ / __and__ are /bitwise/ ops!
logic_and   = lambda x, y   : x and y                             #               ..
const       = lambda x      : (lambda *_, **__: x)                # return the same value irrespective of input
identity    = lambda x      : x                                   # probably the most undervalued operator
between     = lambda a, b   : (lambda x: a<=x<b)                  # missing from module 'operator'?
# our getitem_ always returns a tuple of value(s)
#   for laughs, look up 'operator.itemgetter()' => 3 (three!)
#   different types of return type depending on arguments! FFS!
getitem_    = lambda *n     : (lambda x: tuple(map(x.__getitem__, n)))
setitem_    = lambda n, v   : combine(logic_or, partial(reorder_args(setitem, 2, 0, 1), n, v), identity)
# reorder_args: call f with the arguments indicated by idx:
# call f with args[idx[n]] for 0 <= n < len(idx)
# f will be called with len(idx) arguments. can also be used to select/repeat arguments
reorder_args= lambda f, *idx: (lambda *args, **kwargs: f(*getitem_(*idx)(args), **kwargs))
hasattr_    = lambda a      : partial(reorder_args(hasattr, 1, 0), a)
getattr_    = lambda a      : partial(reorder_args(getattr, 1, 0), a)
# it is "setattr(o, a, v)" but we call it as "setattr_(a, v)(o)" thus a,v,o needs to be reorderd to o, a, v, i.e. 2,0,1
# note that setattr_ returns the object itself so it can be chained
setattr_    = lambda a, v   : combine(logic_or, partial(reorder_args(setattr, 2, 0, 1), a, v), identity)
delattr_    = lambda a      : combine(logic_or, partial(reorder_args(delattr, 1, 0), a), identity)
Map         = lambda f      : partial(map, f)
StarMap     = lambda f      : partial(itertools.starmap, f)
Pam         = lambda *fns   : (lambda *x, **k: map(lambda f: f(*x, **k), fns))
Filter      = lambda f      : partial(filter, f)
Reduce      = lambda f, *a  : partial(reduce, f, *a)
Sorted      = lambda **kws  : partial(sorted, **kws)
GroupBy     = lambda f      : (lambda l: itertools.groupby(l, f))
Zip         = lambda l      : (lambda x: zip(l,x))
Slice       = lambda *args  : (lambda o: getitem(o, slice(*args)))
XformItem   = lambda n, f   : (lambda o: setitem_(n, f(o[n])))
Type        = lambda **kwargs  : type('', (), kwargs)
all_equal   = compose(lambda g: next(g, True) and not next(g, False), itertools.groupby)
#is_iterable = combine(logic_or, hasattr_('__iter__'), hasattr_('__getitem__'))
#listify     = choice(is_iterable, identity, lambda x: [x])
is_none     = partial(is_, None)
if_not_none = lambda f, d=None: choice(is_none, const(d), f)
GetN        = itemgetter
GetA        = attrgetter
Call        = methodcaller
DDict       = collections.defaultdict
Apply       = lambda f, *args, **kwargs: (lambda x: f(x, *args, **kwargs))
# head, tail on lists might be useful!
head        = GetN(0)
tail        = GetN(slice(1,None))

def Raise(x):
    raise x
def Error(f):
    def do_it(x):
        raise RuntimeError(f(x))
    return do_it
Assert  = lambda x, *args, **kwargs: Raise(AssertionError(*args, **kwargs)) if not x else None
AssertF = lambda f, *args, **kwargs: (lambda x: Assert(f(x), *args, **kwargs))

def MSG(pfx = None):
    fmt = ("{0}" if pfx is None else pfx+": {0}").format
    def print_it(x):
        print(fmt(x))
        return x
    return print_it

# filterWith - a filter that acts as "sorted(..., key=fn)
# i.e. filter input based on a predicate on item in stead of on the item
def filterWith(predicate):
    def do_filter(inp):
        result = []
        for item in inp:
            predicate(item) and result.append( item )
        return result
    return do_filter

# this implementation is not the shortest partition() but it is the fastest
#  (pred, list) => (true_list, false_list)
def partition(pred, l):
    ltrue, lfalse = (list(), list())
    for item in l:
        (ltrue if pred(item) else lfalse).append( item )
    return (ltrue, lfalse)
Partition = lambda pred: (lambda l: partition(pred, l))


###################################################
#       An ordered default dict
###################################################
class OrderedDefaultDict(collections.OrderedDict):
    def __init__(self, default_factory=None, *args, **kwargs):
        self.default_factory = default_factory
        super(OrderedDefaultDict, self).__init__(*args, **kwargs)

    def __missing__(self, key):
        if self.default_factory is None:
            raise KeyError("Key '{0}' not found".format(key))
        self[key] = value = self.default_factory()
        return value

###################################################
#       Some time-related functionality
###################################################

# convert any sequence of (y, doy, hh, mm, ss) into seconds-within-year
yhms2sec    = compose(sum, StarMap(mul), Zip([86400*365, 86400, 3600, 60, 1]), Map(int))
# extract those values from an utctimetuple()
utsec_year  = compose(yhms2sec, GetA('tm_year', 'tm_yday', 'tm_hour', 'tm_min', 'tm_sec'), Call('utctimetuple'))
# extract them from a VEX time stamp 
rxVEXtime   = re.compile(r"(?P<y>\d+)y(?P<d>\d+)d(?P<h>\d+)h(?P<m>\d+)m(?P<s>\d+)s$")
vextime2sec = compose(yhms2sec, Call('groups'), rxVEXtime.match, partial(re.sub, r"[ \t\n]*", r""))
utcsec_now  = utsec_year( datetime.datetime.utcnow() )

# convert sign value to int; if it is '-' then return -1, everything else gets +1
sign2int    = choice(partial(eq, "-"), const(-1), choice(partial(eq, "+"), const(1), Error("Unsupported sign character {0}".format)))

class VEXTime(object):
    __slots__  = ['y', 'd', 'h', 'm', 's', 'sign']
    _xform_    = {'y':if_not_none(int, 0), 'd':if_not_none(int, 0), 'h':if_not_none(int,0),
                  'm':if_not_none(int, 0), 's':if_not_none(float,0.0), 'sign':if_not_none(sign2int)}
    # fields to convert from time.time_tuple into our own
    _ttcnv_    = {'tm_year':'y', 'tm_yday':'d', 'tm_hour':'h', 'tm_min':'m', 'tm_sec':'s', 'non_existent':'sign'} 
    _signC_    = {None:"", 1:"+", -1:"-"}
    _signV_    = {int:identity, type(None):const(1), str:sign2int}

    # assume we're constructed from a matchresult from matching rxVEXtime or from an utc_timetuple
    def __init__(self, m):
        if isinstance(m, time.struct_time):
            reduce(lambda a, i: setattr(a, i[1], VEXTime._xform_.get(i[1], identity)
                                        (getattr(m, i[0]) if hasattr(m, i[0]) else None)) or a,
                   VEXTime._ttcnv_.iteritems(), self)
        else:
            reduce(lambda a, k: setattr(a, k, VEXTime._xform_.get(k, identity)(m.get(k, None))) or a,
                   VEXTime._xform_.iterkeys(), self)

    def __add__(self, other):
        if type(other) is type(0):
            return self + sec2VEXTime(other)
        if type(other) is not VEXTime:
            return NotImplemented
        # by using the .seconds property we get the sign handled just fine
        return sec2VEXTime(self.seconds + other.seconds )

    @property
    def seconds(self):
        # depending on the type of the sign attribute's value convert to either +1 or -1
        return VEXTime._signV_[type(self.sign)](self.sign) * yhms2sec( self.tuple )

    # return a tuple (y, d, h, m, s)
    tuple     = property(GetA('y', 'd', 'h', 'm', 's'))

    # fstime is year.doy.hh:mm:ss
    as_fstime = property("{0.y:04d}.{0.d:03d}.{0.h:02d}:{0.m:02d}:{0.s:02.0f}".format)

    def __repr__(self):
        return "{1}{0.y:04d}y{0.d:02d}d{0.h:02d}h{0.m:02d}m{0.s:06.3f}s".format(self, VEXTime._signC_[self.sign])

        
# FIXME TODO XXX   doy is 1-based in output so when reading from string must subtract one
mk_vextime  = compose(VEXTime, Call('groupdict'), rxVEXtime.match, partial(re.sub, r"[ \t\n]*", r""))

####################################################
#  A snap procedure
####################################################
mk_lines = compose(Filter(truth), Map(str.strip), Call('split', '\n'))
lineify  = choice(partial(reorder_args(isinstance, 1, 0), list), identity, mk_lines)

class Procedure(object):
    _defaults = { 'initial_newline': '\n' }
    def __init__(self, name, init_list=None, **kwargs):
        # at most 12 characters in procedure name
        Assert(len(name)<=12, "SNAP procedure name '{0}' is longer than 12 characters".format(name))
        # initialize defaults which could be overriden through kwargs
        reduce(lambda acc, attr: setattr(acc, attr, kwargs.pop(attr, Procedure._defaults.get(attr, None))) or acc,
               Procedure._defaults.keys(), self)
        self.name    = name
        self.lines   = copy.deepcopy(lineify(init_list) if init_list is not None else list())

    def append(self, line):
        self.lines.extend(lineify(line))
        return self

    __hash__  = compose(hash, GetA('name'))

    def __str__(self):
        return "{0}define  {1: <12s} 00000000000x\n".format(self.initial_newline, self.name) + "\n".join(self.lines)+"\nenddef"

###################################################
#       Supported recorders
###################################################

# break string at '\n', strip leading/trailing whitespace, filter out non-empty ones and prepend each one with something
prefix      = lambda pfx: compose(Map(partial(add, pfx)), Filter(truth), Map(str.strip), Call('split', '\n'))
mk5         = prefix("mk5=")
comment     = prefix('"')
rdbe_cmd    = prefix("rdbe_cmd=")
const_lines = compose(const, mk_lines)

class Recorder(object):
    def procedures(self):
        # it'll be jive5ab so we can issue these commands just fine
        return [Procedure("sched_initi", mk5("os_rev?\nversion?"))]

##############   The "none" recorder
class RecorderNone(Recorder):
    __repr__         = const("None")

    # the null recorder has no procedures nor ready_disk/record_{on,off} commands
    procedures       = setup_procedures = ready_disk = record_on = record_off = const(list())#lambda *_, **__: list()


##############   The Mark5C recorder
class Mark5C(Recorder):
    __repr__ = const("Mark5C")

    def __init__(self):
        self.procedure_lst = [Procedure("sched_initi", mk5("ss_rev?"))]

    def procedures(self):
        # mark5c - add firmware version
        return Recorder.procedures(self) + self.procedure_lst

    # depending on Setup's props, generate the appropriate commands to add to
    # one or more procedures
    def setup_procedures(self, setup):
        Assert(setup.firmware in ["PFB", "DDC4", "DDC8"],
               "The setup's firmware {0} is not supported by the recorder".format(setup.firmware))
        # we need to append to the setup's procedure at the very least
        setup_p = Procedure(setup.setup)
        if setup.firmware == "PFB":
            # pfb outputs Mark5B as 2x5008 byte frames w/ broken sequence number
            # (32 bits in 64 bit word and at the wrong half at that)
            setup_p.append( mk5("packet=36:0:5008:0:0;") )
            # need to generate the mode=
            setup_p.append( mk5("mode=MARK5B-{0.datarate}-{0.nChannel}-2".format(setup)) )
        else:
            # DDC mode outputs VDIF
            setup_p.append( mk5("packet=36:0:8224:0:0;") )
            setup_p.append( mk5("mode=VDIF_8224-{0.datarate}-{0.nChannel}-2".format(setup)) )
        return [setup_p]

    # what needs to be done on ready_disk at start of experiment
    # and what to do to switch recording on/off
    ready_disk = const_lines("ready_disk\nbank_set?\npointers?\nbank_info?")
    record_on  = const_lines("disk_pos\ndisk_record=on\ndisk_record\ndata_valid=on")
    record_off = const_lines("data_valid=off\ndisk_record=off\ndisk_pos")

##############   The Mark6 recorder
class Mark6(Recorder):
    __repr__ = const("Mark6")

    def __init__(self, disks=None):
        initi = Procedure("sched_initi")
        # flexbuff/mark6 recording RDBE must be done on port 625 apparently
        # net_protocol pudp/udps will be set depending on setup
        # but buffer sizes &cet can already be set
        initi.append( comment("""preconfigure as much as we can. the actual net_protocol\n
                              will be set in the setup, it is firmware dependent""") )
        initi.append( mk5("net_port=625\nmtu=9000\nnet_protocol=:32M:256M:4") )
        initi.append( mk5("set_disks={0}".format("mark6" if disks is None else disks)) )
        self.procedure_lst = [initi]

    def procedures(self):
        return Recorder.procedures(self) + self.procedure_lst

    # depending on Setup's props, generate the appropriate commands to add to
    # one or more procedures
    def setup_procedures(self, setup):
        Assert(setup.firmware in ["PFB", "DDC4", "DDC8"],
               "The setup's firmware {0} is not supported by the recorder".format(setup.firmware))
        # we need to append to the setup's procedure at the very least
        setup_p = Procedure(setup.setup)
        if setup.firmware == "PFB":
            # pfb outputs Mark5B as 2x5008 byte frames w/ broken sequence number
            # (32 bits in 64 bit word and at the wrong half at that)
            # There is a compile-time option in jive5ab to decode these sequence numbers
            # (FILA=1) but then we need to swap executables ....
            # Maybe I'll add an "udps32" net_protocol to support this format dynamically
            setup_p.append( mk5("net_protocol=udpsnor\nmtu=5100") )
            # need to generate the mode=
            setup_p.append( mk5("mode=MARK5B-{0.datarate}-{0.nChannel}-2".format(setup)) )
        else:
            # DDC mode outputs 8224 byte VDIF w/o sequence number?
            setup_p.append( mk5("net_protocol=pudp\nmtu=9000") )
            setup_p.append( mk5("mode=VDIF_8224-{0.datarate}-{0.nChannel}-2".format(setup)) )
        return [setup_p]

    # what needs to be done on ready_disk at start of experiment
    # and what to do to switch recording on/off
    ready_disk = const(mk5("set_disks?"))
    record_on  = const_lines("disk_record=on\ndisk_record\ndata_valid=on")
    record_off = const_lines("data_valid=off\ndisk_record=off")

#############################################################################
#
#                      Commandline parsing
#
#############################################################################
class PrintHelp(argparse.Action):
    def __call__(self, the_parsert, *args):
        the_parsert.print_help() or sys.exit( 0 )

arg0_or_zero = choice(truth, itemgetter(0), const(0))
def usage(*args):
    # http://stackoverflow.com/a/1676860
    import pydoc, inspect
    # extract the documentation at the top of this module, put it through pydoc.pager and then exit :-)
    return compose(const(arg0_or_zero(args)), pydoc.pager, inspect.getcomments, itemgetter(__name__))(sys.modules)

class PrintUsage(argparse.Action):
    def __call__(self, the_parsert, *args):
        sys.exit( usage() )

# an action which (attempts to) map a recorder type string into an actual type
recorder_mapping  = {'mark5c':Mark5C, 'mark6':Mark6, 'none':RecorderNone}
get_recorder_type = compose(choice(recorder_mapping.__contains__, recorder_mapping.__getitem__,
                            Error("Unknown recorder type {0}".format)), str.lower)
def recorder_type(rec):
    rec = rec.split(':')
    return get_recorder_type(rec[0])(*rec[1:])

# convert a string into a time offset
# --shift 'today' | [-+]<vextime>
#  'today'                  shift day of observation to today
#  <vexime>                 shift day of observation to day-of-year in time stamp
#  +<vextime>, -<vextime>   add/subtract this much to each time stamp
rxVEXOffset = re.compile(r"^(?P<sign>[-+])?((?P<y>\d+)y)?((?P<d>\d+)d)?((?P<h>\d+)h)?((?P<m>\d+)m)?((?P<s>\d+)s)?$")
as_vextime  = compose(VEXTime, Call('utctimetuple'))
maybe_today = choice(partial(eq, "today"), lambda _: as_vextime(datetime.datetime.utcnow()), const(None))
check_shift = compose(choice(is_none, Error("time-shift argument is not a vextime or 'today' (see --help)"), identity),
                      combine(logic_or, compose(if_not_none(compose(VEXTime, Call('groupdict'))), rxVEXOffset.match), maybe_today),
                      partial(re.sub, r"[ \t\n]*", ""), str.strip, str.lower)
# The codes uses a sidereal day length of 23 hours, 56 minutes, 4seconds
# when shifting by a number of days
# (https://en.wikipedia.org/wiki/Sidereal_time)
siderealday = mk_vextime("0y0d23h56m4s")

# input:  string
# output: function which returns a function which modifies a time stamp by a certain amount of seconds
#         based upon the vex object given
def shift(shift):
    vext = check_shift(shift)
    # if there was a sign, it means a relative shift
    if vext.sign is not None:
        print("Shifting all UCT times by ",vext)
        # given any vex object, always return a function which
        # just adds the number of seconds requested
        return const(partial(add, vext.sign*vext.seconds))
    else:
        # Move to specific day (today, or specific year+doy)
        # so, given a vex object, we extract the nominal start time and compute the shift wrt to that one
        def compute_shift(vexf):
            nominal_start = NominalStart(vexf)
            # arrange for offset such that if vext > nominal_start the diff is positive
            # each day adds 23h56m4s 
            offset = (365 * (vext.y - nominal_start.y) + vext.d - nominal_start.d) * siderealday.seconds + \
                     (vext.h - nominal_start.h) * 3600 + (vext.m - nominal_start.m) * 60 + (vext.s - nominal_start.s)
            return partial(add, offset)
        return compute_shift


parsert = argparse.ArgumentParser(description="Transform VEX files to .snp/.prc", add_help=False)
parsert.add_argument('-h',   nargs=0, action=PrintHelp, help="Show this help message and exit succesfully")
parsert.add_argument('--help',  nargs=0, action=PrintUsage, help="Show built-in usage")
parsert.add_argument('--debug',  dest='debug', action='store_true', default=False, 
                     help="Print debugging information")
parsert.add_argument('-v', '--version', action='version', version=version, help="Print current version and exit succesfully")
parsert.add_argument('--dest', dest='output_path', type=str, default="/usr2/sched",
                     help="Location where to store output .prc/.snp files")
parsert.add_argument('--force', dest='file_exists', action="store_const", const=const(False), default=os.path.isfile,
                     help="Overwrite existing output files (default: don't)")
parsert.add_argument('--station', dest='station', type=str, required=True,
                     help="The station two-letter-codefor which to generate the .prc/.snp files")
parsert.add_argument('--recorder', dest='recorder', type=recorder_type, default=None,
                     help="The recorder type (Mark5C, Mark6) to use")
parsert.add_argument('--ignore-utc', dest="utc_limit", default=utcsec_now, action="store_const", const=0,
                     help="Ignore current UTC time - i.e. just process all scans even when they cannot be observed anymore")
parsert.add_argument('--shift', dest='utc_shift', type=shift, default=const(const(identity)),
                     help="Shift all UTC time stamps in the schedule (see --help for details)")
parsert.add_argument("vexfiles", nargs='*', help="One or more vexfiles to process")

###################################
# Actually parse the command line #
###################################
userinput = parsert.parse_args()

# Take some actions based on what the user gave us (debug e.g.)
if userinput.debug:
    D     = MSG("DEBUG")
    DD    = lambda y: MSG(y)
    level = 0
    def Trace(f, pfx=None):
        fmt = ("{0} {1}" if pfx is None else pfx+": {0} {1}").format
        def call(*args, **kwargs):
            global level
            print("TRACE:","  "*level,fmt(args, kwargs))
            level += 1
            rv = f(*args, **kwargs)
            print("      ","  "*level,"  ==>",rv)
            level -= 1
            return rv
        return call
else:
    D     = identity
    DD    = const(identity)
    Trace = lambda f, *args, **kwargs: f
    def silent_except_hook(tp, val, tb):
        print(str(val))
    sys.excepthook = silent_except_hook

#################################################################################################
#
#                 Handle a single vex file
#
#################################################################################################
fileExists = choice(os.path.isfile, identity, compose(Raise, RuntimeError, partial(add, "File does not exist: ")))

# transform /path/to/file.vex => file
#  .split() => (/path/to, file.vex)
#  .splitext() => (file, vex)
vexName    = compose(GetN(0), os.path.splitext, GetN(1), os.path.split)

# input: vexfile name, output: functions generating the names of the output file(s) given a station
fn_func      = lambda ext: (lambda base: compose("{0}{{0}}.{1}".format(base.lower(), ext.lower()).format, str.lower))
add_prefix   = partial(os.path.join, userinput.output_path)
output_files = lambda vexobj, station: compose(DD("Output files"), Map(compose(add_prefix, ylppa(station))),
                                               Pam(*map(fn_func, ['snp', 'prc', 'lst'])), Slice(0,6),
                                               str.lower, next, Call('iterkeys'), GetN('EXPER'))(vexobj)

# Filter the given list-of-files using userinput.file_exists. Non-empty list raises an error.
ok_to_write  = compose(choice(truth,
                              compose(Raise, RuntimeError, "Output file(s) {0} exist. Use --force to forcibly overwrite".format),
                              identity),
                       list, Filter(userinput.file_exists))


###############################################################################
#
#                      Dealing with vex content
#
###############################################################################

# wrapper to turn opening a vex file into a context so 
# this works: 
#    with OpenVex(filename) as vexf: 
#        <stuff with vexf>
class OpenVex(object):
    def __init__(self, filename):
        self.filename = filename
    def __enter__(self):
        self.vex = Vex(self.filename)
        return self.vex
    def __exit__(self, e, t, f):
        return

# decomposing seconds into year, day, hh, mm, ss
# feed in: what to do with the components (e.g. string formatting, make tuple with attr name+value?)
#          what to do with the result?
def mk_reductor(outer_reductor):
    def inner_reductor(inner_acc, field_action):
        (time, outer_acc) = inner_acc
        (divisor,     fn) = field_action
        (whole, remain)   = (remain, 0) if divisor is None else divmod(time, divisor)
        return (remain, outer_reductor(outer_acc, fn(whole)))
    return inner_reductor

# given a list of field actions and a reductor function
# return a function which will decompose a number of seconds into a succession
# of years, days, hours, minutes, seconds, call the field actions on them
# and use the reducing functions to produce (remain, result)
# If seconds is fractional, the final element can be retrieved by having one more action
def decompose_seconds(reductor, actions):
    field_actions  = zip([365*86400, 86400, 3600, 60, 1, None], actions)
    inner_reductor = mk_reductor(reductor)
    def _reduce(seconds, init):
        return reduce(inner_reductor, field_actions, (seconds, init))
    return _reduce

# Assert that the remainder of a second reduction is 0
check_int_tm = choice(GetN(0), Error("Non-integer second time stamp is unacceptable".format), GetN(1))

# FIXME TODO XXX   doy is 1-based in output so when reading from string must subtract one
#  vextime format 0000y000d00h00m00s
vextimefields=["{0:04d}y".format, "{0:03}d".format, "{0:02d}h".format, "{0:02d}m".format, "{0:02d}s".format]
sec2vextime_ = decompose_seconds(add, vextimefields)
sec2vextime  = lambda seconds: check_int_tm(sec2vextime_(seconds, ""))

#  snap time formt 0000.000.00:00:00
fstimefields =["{0}.".format, "{0}.".format, "{0:02d}:".format, "{0:02d}:".format, "{0:02d}".format]
sec2fstime_  = decompose_seconds(add, fstimefields)
sec2fstime   = lambda seconds: check_int_tm(sec2fstime_(seconds, ""))

# Write the decomposed elements from seconds directly into an empty VEXTime
SetAttr       = lambda acc, action: setattr(acc, action[0], action[1]) or acc
vtactions     = map(lambda a: (lambda v: (a, v)), "ydhms")
sec2VEXTime   = lambda seconds: decompose_seconds(SetAttr, vtactions)(seconds, VEXTime(dict()))[1]

intSec        = compose(int, str.strip, partial(re.sub, r"s(ec)?", r""))

class Scan(object):
    __slots__ = ['mode', 'label', 'nominal_start', 'source', 'offset', 'duration']
    __xform__ = {'offset':intSec, 'duration':intSec, 'nominal_start':mk_vextime}

    # assume we're constructed from a vexobject describing an entry in "$SCHED;"
    def __init__(self, **obj):
        reduce(lambda a, k: setattr(a, k, Scan.__xform__.get(k, identity)(obj.get(k, None))) or a, Scan.__slots__, self)
        Assert(self.duration>self.offset, "Attempt to observe scan where data-good > scan duration")

    # .start, .end                 are the values in units of seconds
    # .nominal_start, .nomimal_end are the VEXTime objects
    start       = property(lambda s: s.nominal_start.seconds + s.offset)
    end         = property(lambda s: s.nominal_start.seconds + s.duration)
    nominal_end = property(lambda s: s.nominal_start + s.duration)
    label_snap  = property(compose(str.lower, GetA('label')))

    __repr__ = method("{0.label}: {0.source} from {0.nominal_start}+{0.duration} using {0.mode}".format)


def station_scan(station):
    # scan == (scanId, <vex scan obj>)
    def station_observes(scan):
        (scanId, scanObj) = scan
        #station=Eb:    0 sec:  620 sec:   42.961 GB:   :       : 0;
        #        0      1       2          3               4      5
        station_line      = filter(compose(partial(eq, station), GetN(0)), scanObj.getall('station'))
        station_line      = station_line[0] if station_line else None
        if not station_line:
            return None
        return Scan(mode=scanObj['mode'], nominal_start=scanObj['start'], source=scanObj['source'],
                    offset=station_line[1], duration=station_line[2], label=scanId)
    return station_observes

# Filter the list of scans for the indicated station and also
# filter out the ones that are in the past
end_in_future     = compose(partial(lt, userinput.utc_limit), GetA('end'))
get_station_scans = lambda station: compose(Filter(end_in_future), Filter(truth), Map(station_scan(station)), Call('iteritems'), GetN('SCHED'))


#ra = 00h41m41.2986000s; dec =  -41d03'32.995800"; ref_coord_frame = J2000;
radec2snap = choice(is_none, Error("Attempt to convert an RA/DEC of None to SNAP"),
                    compose(choice(re.compile(r"^\d+h\d+m\d+(\.\d*)?s|-?\d+d\d+'\d+(\.\d*)?\"$").match,
                                   partial(re.sub, r"[hmsd'\"]", ""), 
                                   Error("The coordinate {0} does not conform to format for RA or DEC".format)),
                            str.strip, str.lower))

ref2snap = choice(is_none, Error("Attempt to convert an RA/DEC of None to SNAP"),
                  choice(compose(partial(eq, "J2000"), str.upper, str.strip),
                         const("2000"), Error("The coordinate reference frame {0} is not J2000".format)))

# Build dict { SOURCE-def: Source(), ... }
class Source(object):
    __slots__ = ['source_name', 'ra', 'dec', 'ref_coord_frame']
    #__xform__ = {'ra':str2ra, 'dec':str2dec}

    # initialize from keywordargs
    def __init__(self, **kwargs):
        reduce(lambda acc, attr: setattr(acc, attr, kwargs.pop(attr, None)) or acc, Source.__slots__, self)

    # ra,dec in snap format are basically stuff from the vex file with hms
    # and d'" removed?
    ra_snap              = property(compose(radec2snap, GetA('ra')))
    dec_snap             = property(compose(radec2snap, GetA('dec')))
    ref_coord_frame_snap = property(compose(ref2snap, GetA('ref_coord_frame')))

    __str__  = method("{0.source_name}@RA/DEC={0.ra}/{0.dec} {0.ref_coord_frame}".format)
    __repr__ = __str__


def mk_source(vexobj):
    return reduce(lambda acc, a: setattr(acc, a, vexobj[a]) or acc, Source.__slots__, Source())

# given vexfile, extract all $SOURCE; entries and return { SOURCE-def: Source(), ... }
source_lut = compose(dict, Map(Pam(GetN(0), compose(mk_source, GetN(1)))), Call('iteritems'), GetN('SOURCE'))


class Site(object):
    __slots__ = ['site_name', 'site_position']
    __xform__ = {'site_position': Map(compose(float, str.strip, partial(re.sub, "m", "")))}

    def __init__(self, vexobj):
        reduce(lambda acc, attr: setattr(acc, attr, Site.__xform__.get(attr, identity)(vexobj[attr])) or acc, Site.__slots__, self)

    __str__            = method("site {0.site_name} @{0.site_position}".format)
    site_position_snap = property(compose(" ".join, Map(str), GetA('site_position')))

class DAS(object):
    __slots__ = ['record_transport_type', 'electronics_rack_type']
    __xform__ = {'record_transport_type': recorder_type}

    def __init__(self, vexobj):
        reduce(lambda acc, attr: setattr(acc, attr, DAS.__xform__.get(attr, identity)(vexobj[attr])) or acc, DAS.__slots__, self)

    __str__  = method("Rack {0.electronics_rack_type} Recorder {0.record_transport_type}".format)

# resolve a station into SITE and DAS (ANTENNA not currently necessary)
class Station(object):
    __slots__ = ['site', 'das']
    __xform__ = {'site':Site, 'das':DAS }

    def __init__(self, **kwargs):
        reduce(lambda acc, a: setattr(acc, a, Station.__xform__.get(a, identity)(kwargs.pop(a, None))) or acc, Station.__slots__, self)

    __str__   = method("Station: {0.site} {0.das}".format)

has_station  = lambda station: compose(Call('__contains__', station), list, Call('iterkeys'))
station_defs = lambda station: compose(Pam(*map(GetN, ['SITE', 'DAS'])),
                                       choice(has_station(station), GetN(station),
                                              Error("The station {0} does not exist in the $STATION section".format(station).format)),
                                       GetN('STATION'))

def mk_station(vexfile, station):
    (site_def, das_def) = station_defs(station)(vexfile)
    return Station(site=vexfile['SITE'][site_def], das=vexfile['DAS'][das_def])

# From a MODE extract the IF, FREQ, BBC, TRACKS, PHASE_CAL_DETECT for the requested station.
# In the VEX file these are ref lines so format is:
#   ref $REF = <defname> : station : station : ... ;
#   ref $REF = <defname> : station : station : ... ;
#
#   mode.iteritems() gives us a sequence of:
#      [ (REF-name, [<defname>, station, station, ...]),
#        (REF-name, [<defname>, station, station, ...], .. ]
# So we filter the required REF-name's that we need, keeping only the entry
# where the requested station is in the list of stations following the <defname>.
# 
# Eventually we produce a dict with entries like this:
#       {"mode": ("setupXX", <mode-for-station>)}
# 
#  where <mode-for-station> == { 'BBC': "defname>, 'IF': "defname", ... }


# extract <vexfile>['MODE'][mode] <object> and set <object>.mode = "mode"
get_mode         = lambda vexobject: lambda mode: compose(setattr_('mode', mode), GetN(mode), GetN('MODE'))(vexobject)
# set <mode object>.setup = "setupXX", auto-counting from 1
enumerate_setups = lambda mode, cnt=itertools.count(1): setattr_('setup', "setup{0:02d}".format(next(cnt)))(mode)
# Which ref lines we need and how to tell which one applies to a particular station
needed_refs      = set(['IF', 'FREQ', 'BBC', 'TRACKS', 'PHASE_CAL_DETECT'])
is_for_station   = lambda station  : lambda l: l[0] if station in l[1:] else None
refs_for_station = lambda st, modes: reduce(lambda acc, mode:
                                     acc.update( {mode.mode:(mode.setup,
                                                             compose(dict, Map(compose(tuple, Pam(GetN(0), compose(GetN(0), GetN(1))))),
                                                                     Filter(compose(is_for_station(st), GetN(1))),
                                                                     Filter(compose(needed_refs.__contains__, GetN(0))),
                                                                     list, Call('iteritems'))(mode)) } ) or acc, modes, dict())

###############################################################################
##    moving on to decoding
###############################################################################

mk_vex_lut = lambda sect, defname, key:compose(DD("VEX lut[{0}.{1}".format(sect,defname)), dict, Map(Pam(head, tail)),
                                               Call('getall', key), GetN(defname), GetN(sect))

# shorthands for converting vex file values to canonical things
fltMHz       = choice(truth, compose(float, str.strip, partial(re.compile(r'[ \t]*MHz').sub, "")), const(None))
sideband_    = { 'U': 'usb', 'L': 'lsb' }
canon_sb_f   = compose(sideband_.__getitem__, str.upper)
canon_pol_f  = str.lower
canon_if_f   = str.lower
pcal_state_f = choice(is_none, const("pcaloff"), const("pcalon"))
canon_pcal_f = choice(is_none, const("off"), int)
# there is a mapping of IF_A/B => input 0 and C/D to 1
inp_zero     = "AaBb"
inp_one      = "CcDd"
if_to_inp    = choice(inp_zero.__contains__, const(0),
                      choice(inp_one.__contains__, const(1),
                             Error("No known mapping for IF{0} to RDBE input".format)))

pfb_split  = compose(enumerate, Filter(truth), Partition(lambda x: x.sb == 'lsb'))
# group list of channels by their IF and return [(IF, <channels>), ...]
# Note: groupby() returns tuples with (key, <iterable>) but the <iterable> can be
#       used only once. So we transform that into a list
if_key     = GetA('abcd')
split_by_if= compose(Map(lambda t: (t[0], list(t[1]))), GroupBy(if_key), Sorted(key=if_key))
# given list of CHxx channel refs, sort numerically by xx
int_key    = lambda *args: compose(int, Call('group', 1), re.compile(*args).match)
int_sorted = lambda *args: Sorted(key=int_key(*args))
#chet's 'upper edge' table, modified to add 1024, leave out 528
# (verbatim from vex2snap.pl)
chet_fh    = [1024,1008,976,944,912,880,848,816,784,752,720,688,656,624,592,560];
lookup_fh  = choice(chet_fh.__contains__, chet_fh.index, Error("Unmapped PFB channel frequency {0}".format))

inputs     = lambda: (itertools.product( ["dbe0", "dbe1"], range(2) ))
concat     = Reduce(add)          # input: iterable-of-lists, output one list

# Post-process the iochannel assignments
def mk_ioch_(acc, item):
    # item = (dbe, <dict>)
    dbe, ch_dict = item
    cmd = "rdbe_cmd="+dbe+",5,dbe_ioch_assign="
    # loop over the channels in vex order because that's
    # how they need to be written?
    for ch in sorted(ch_dict.iterkeys(), key=int_key("^CH(\d+)")):
        cmd += "{0}:{1}::".format( *ch_dict[ch] )
    cmd += ";"
    return acc.append( cmd ) or acc
mk_ioch = lambda l: reduce(mk_ioch_, l, list())

# input:  setup.dbes_used, which is: set( (<dbe>, <input>), ... )
# output: set of unique <dbe>'s 
get_dbes     = compose(set, Map(GetN(0)))
# From a dict {"mode":Setup(), ...}, extract ".dbes_used" (see above)
# transform that entry (identity, GetN(0) (==DBE), GetN(1) (==Input), ...)
# and uniquefy that over all setups
get_all_dbes_ = lambda xform: compose(Reduce(set.union), Map(compose(set, Map(xform), GetA('dbes_used'))), Call('itervalues'))
# From a dict {"mode":Setup(), ...}, extract the set of all dbe's used over all setups
get_all_dbes   = get_all_dbes_(GetN(0)) #compose(Reduce(set.union), Map(compose(get_dbes, GetA('dbes_used'))), Call('itervalues'))
get_all_inputs = get_all_dbes_(identity)

###############################################################################
#
#  Process the channels based on deduced type of firmware
#  and generate the RDBE procedure
#
###############################################################################
def fqlist_pfb(setup):
    # put all channels of one kind of sideband in one DBE, filter out
    # ones that don't have channels and enumerate the resulting channel lists
    fqs            = list()
    los, rdbe_los  = (dict(), dict())
    clrs           = DDict(list)
    # Keep a mapping of DBE => [CHref => (inp, ch)] in order to be able 
    # to generate the correct "dbe_ioch_assign" command
    iochs          = DDict(dict)   # map (CHref) => (inp, ch)
    pcal_s         = set()    # set of pcal states, can assert we only have one
    rdbe_inp       = inputs() # allow us to loop over all inputs
    
    for IF, ch_list in split_by_if(setup.channels):
        # we could split it up in chunks of 16 channels and route the same IF
        # to multiple RDBE inputs but for now we don't
        Assert(len(ch_list)<=16, "Cannot do more than 16 channels per RDBE IF input")

        # assign those channels to the next available input
        (dbe, inp) = next(rdbe_inp)
        if dbe not in clrs:
            #clrs[dbe].append( "rdbe_person={dbe},pfb".format(dbe=dbe) )
            clrs[dbe].append( "rdbe_send={dbe},off".format(**locals()) )
            clrs[dbe].append( "rdbe_cmd={dbe},50,dbe_personality=pfbg:pfbg_1_4.bin".format(dbe=dbe) )
            clrs[dbe].append( "rdbefclr={dbe}".format(dbe=dbe) )
        # count channels per IF
        for (chan, ch) in enumerate(ch_list, start=1):
            # convert channel properties to stuff we need
            ch_frq = int(ch.freq - ch.lo)
            iif    = if_to_inp(ch.abcd)
            ich    = lookup_fh(abs(ch_frq))  # look up channel freq in table to find index
            setup.dbes_used.add( (dbe, iif) )
            # Get current pcal state
            pcal_s.add( pcal_state_f(ch.pcal) )
            # did we set the LO for this (IF,input)?
            loc    = "lo{ch.canon_if}".format( **locals() )
            if (loc, iif) not in los:
                los[(loc, iif)] = "lo="+loc+",{ch.lo:.2f},{ch.canon_if_sb},{ch.canon_pol}cp,{ch.canon_pcal}".format(**locals())
                rdbe_los[(loc, iif)] = "rdbe_if="+loc+",{ch.lo:.2f},{ch.canon_if_sb},{ch.canon_pol}cp,{dbe},if{iif}".format(**locals())
            # Append a line describing this channel
            fqs.append( "rdbef{ch.bbc:02d}={dbe},if{iif},{ch.freq:.2f},{ch.bw},{ch.canon_sb},{ch.canon_pol},{ich}".format(**locals()) )
            # Put it in the ioch mappings
            iochs[ dbe ][ ch.ch_ref ]= (iif, ich)

    # assert there's only one pcal state
    Assert(len(pcal_s)==1, "Inconsistent PCAL states - more than one found")

    # for all used dbes enable send again
    enable_send = reduce(lambda acc, x: acc.append("rdbe_send={0},on".format(x)) or acc, get_dbes(setup.dbes_used), list())
    # concatenate all commands - take care of re-ordering the "rdbefXX" commands by XX
    return [pcal_state_f(pcal_s.pop())] + los.values() + concat(clrs.values())+sorted(fqs, key=int_key(r"^rdbef(\d+)", re.I)) + \
           rdbe_los.values() + mk_ioch(iochs.iteritems()) + enable_send

# distribute the DDC channels over the RDBE inputs 
# according to vex2snap.pl
#   if dual pol 8 channel, send R to dbe0 and L to dbe1
# otherwise assign ch 0-3 to DBE0, 4-7 to DBE1
pol_key      = GetA('pol')
split_by_pol = compose(Map(lambda t: (t[0], list(t[1]))), GroupBy(pol_key), Sorted(key=pol_key))

# given: list of [(pol, [channels]), (pol, [channels])]
# return:  ( dual-pol <bool>,
#            total-nr-channels <int>,
#            each-pol-same-nr-channels <bool>,
#            max-nr-channels-per-pol <int> )
check_dual_p = compose(Pam(compose(partial(eq, 2), len), sum, all_equal, max), Map(compose(len, GetN(1))))
ddc_channels = lambda: (itertools.product( ["dbe0", "dbe1"], range(4) ))
invert_sb_   = {'l':'u', 'lsb':'usb', 'u':'l', 'usb':'lsb'}
invert_sb    = compose(choice(invert_sb_.__contains__, invert_sb_.__getitem__, Error("Unknown sideband {0}".format)), str.lower) 

# RDBE setting up DownConverters is tricky, must use first match in the tables.
# for upper side band           DDS freq       M  S  [M=Mode S=Sub]
usb_table    =[ lambda fq, bw:  (fq-512+bw/2,  1, 2) if fq<=(640-bw)   else None
              , lambda fq, bw:  (768-fq-bw/2,  0, 1) if fq<=(768-bw)   else None
              , lambda fq, bw:  (768-fq-bw/2,  0, 1) if fq<=(768-bw/2) else None
              , lambda fq, bw:  (fq+bw/2-768,  1, 1) if fq< (768)      else None
              , lambda fq, bw:  (fq-768+bw/2,  1, 1) if fq<=(896-bw)   else None
              , lambda fq, bw:  (1024-fq-bw/2, 0, 0) if fq<=(1024-bw)  else None]
# for lower side band           DDS freq       M  S  [M=Mode S=Sub]
lsb_table    =[ lambda fq, bw:  (1024-fq+bw/2, 1, 0) if fq>=(896+bw)   else None
              , lambda fq, bw:  (fq-768-bw/2,  0, 3) if fq>=(768+bw)   else None
              , lambda fq, bw:  (fq-768-bw/2,  0, 3) if fq>=(768+bw/2) else None
              , lambda fq, bw:  (768-fq+bw/2,  1, 3) if fq>=(768)      else None
              , lambda fq, bw:  (768-fq+bw/2,  1, 3) if fq>=(640+bw)   else None
              , lambda fq, bw:  (fq-512-bw/2,  0, 2) if fq>=(512+bw)   else None]

# This function executes the functions in the table selected by sideband and
# returns the first entry that is not None
get_dds_cfg = lambda sb, fq, bw: compose(next, partial(itertools.dropwhile, is_none),
                                         Map(lambda f: f(fq, bw)))(usb_table if sb in ['u', 'usb'] else lsb_table)

# input: dict of {<dc#> : <phys inp>, ... }
# produce string "dbe_xbar=<phys inp>:<phys inp>:<phys inp>[:<dummy entries up until DC07 imput>;"
#  sorted by <dc#>
mk_xbar_ = lambda tbl: "dbe_xbar="+":".join(map(str, getitem_(*sorted(tbl.keys()))(tbl)))+ ":".join(["2"]*(8-len(tbl)))+";"
# input: dict of { dbe : dc#-to-phys-input-mapping }
# output: list of [ "rdbe_cmd=dbe0,3,dbe_xbar=3:3:3:2:2:2:2:2;", ... ]
mk_xbar  = compose(Map(compose(Reduce(add), Pam(compose("rdbe_cmd={0},3,".format, GetN(0)), compose(mk_xbar_, GetN(1))))),
                   Call('iteritems'), DD("xbar-cfg"))
# input:  dict of { <dbe>: [0,2,4,..] } VDIF thread assignments
# output: [ "rdbe_cmd=<dbe>,3,dbe_vdif_threads_id=0,2,4;", ... ]
mk_vdif_ = lambda lst: "dbe_vdif_threads_id="+":".join(map(str, lst))+";"
mk_vdif  = compose(Map(compose(Reduce(add), Pam(compose("rdbe_cmd={0},3,".format, GetN(0)), compose(mk_vdif_, GetN(1))))),
                   Call('iteritems'), DD("vdif-thread-cfg"))

def fqlist_ddc(setup):
    # put all channels of one kind of sideband in one DBE, filter out
    # ones that don't have channels and enumerate the resulting channel lists
    dbes, fqs, dcs = (list(), list(), list())
    los, rdbe_los  = (dict(), dict())
    clrs           = DDict(list)
    vdif           = DDict(list)
    # Keep a mapping of channel  => (dbe, ch) in order to be able 
    # to generate the correct xbar commands and downconverter commands
    ch_assign      = dict()
    pcal_s         = set()    # set of pcal states, can assert we only have one
    xbar           = DDict(dict)
   
    # get list: [ (pol, [channels]), (pol, [channels]), ...]
    chans_by_pol   = split_by_pol(setup.channels)

    # for dual pol dual rdbe we require: total nr of channels > 4 and #-right-pol == #-left-pol
    (dual_pol, n_chan_tot, same_nch_pol, max_chan_pol) = check_dual_p( chans_by_pol )

    # some assertions never hurt
    Assert(n_chan_tot<=8, "DDC mode cannot support {0} channels, it is limited to <=8".format(n_chan_tot))
    # this constraint could be different between how flexible IFs can be routed to RDBE inputs
    Assert(max_chan_pol<=4, "DDC mode cannot support {0} channels / polarization, it is limited to <=4".format(max_chan_pol))

    # Assign channels to DBE inputs, based on what we seem to have found
    if dual_pol and same_nch_pol and n_chan_tot>4:
        # dual pol > 4 channels, assign each pol to one DBE 'r' => dbe0, 'l' => dbe1
        for pol, ch_list in chans_by_pol:
            dbe = "dbe0" if canon_pol_f(pol) == 'r' else "dbe1"
            # send all channels to this DBE
            for ich, ch in enumerate(ch_list):
                ch_assign[ ch ] = (dbe, ich)
    else:
        # Distribute the channels over the available DBE's and channels-within-DBE
        available_channels = ddc_channels()
        for ch in channels:
            ch_assign[ ch ] = next(available_channels)

    # Now that we've assigned channels, we can configure the downconverters,
    # the xbar and the VDIF thread assignment
    for ch, assign in ch_assign.iteritems():
        (dbe, ich) = assign
        # convert channel properties to stuff we need
        ch_frq     = int(ch.freq - ch.lo)
        iif        = if_to_inp(ch.abcd)
        setup.dbes_used.add((dbe, iif))
        # Get current pcal state
        pcal_s.add( pcal_state_f(ch.pcal) )
        # did we set the LO for this (IF,input)?
        loc    = "lo{ch.canon_if}".format( **locals() )
        if (loc, iif) not in los:
            los[(loc, iif)] = "lo="+loc+",{ch.lo:.2f},{ch.canon_if_sb},{ch.canon_pol}cp,{ch.canon_pcal}".format(**locals())
            rdbe_los[(loc, iif)] = "rdbe_if="+loc+",{ch.lo:.2f},{ch.canon_if_sb},{ch.canon_pol}cp,{dbe},if{iif}".format(**locals())
        # configure the downconverter
        decimation, rem = divmod(128, ch.bw)
        Assert(rem==0, "Channel bandwidth {0} not supported by DDC".format(ch.bw))
        # check for lower/upper side band
        sb = copy.deepcopy(ch.sb)
        if ch_frq<0:
            ch_frq = -ch_frq
            sb     = invert_sb(sb)
        sb = canon_sb_f(sb)
        # Append a line describing this channel
        # Note: the last digit is the channel and all DDC channels get
        #       stuffed into IF0. rdbe_tsys.c expects this.
        fqs.append( "rdbef{ch.bbc:02d}={dbe},if{iif},{ch.freq:.2f},{ch.bw},{sb},{ch.canon_pol},0".format(**locals()) )
        # Get the downconverter config
        (dds_freq, mode, sub) = get_dds_cfg(sb, ch_frq, ch.bw)
        dcs.append( "rdbe_dc_cfg={dbe},{ich}:{decimation}:{dds_freq:.2f}:{mode};".format(**locals()) )
        # and the xbar
        xbar[ dbe ][ ich ] = sub + iif*4
        vdif[ dbe ].append( ch.bbc-1 )

    # add commands to load personality and clear
    for dbe in get_dbes(setup.dbes_used):
        clrs[dbe].append( "rdbe_send={dbe},off".format(**locals()) )
        clrs[dbe].append( "rdbe_cmd={dbe},50,dbe_personality=ddc:ddc_1601583.bin".format(dbe=dbe) )
        clrs[dbe].append( "rdbefclr={dbe}".format(dbe=dbe) )

    # for all used dbes enable send again
    enable_send = reduce(lambda acc, x: acc.append("rdbe_send={0},on".format(x)) or acc, get_dbes(setup.dbes_used), list())

    # assert there's only one pcal state
    Assert(len(pcal_s)==1, "Inconsistent PCAL states - more than one found")
    return [pcal_state_f(pcal_s.pop())] + los.values() + concat(clrs.values()) + sorted(fqs, key=int_key(r"^rdbef(\d+)", re.I)) +\
           rdbe_los.values() + dcs + mk_xbar(xbar) + mk_vdif(vdif) + enable_send


# lookup table
fqlist_fn   = {'PFB': fqlist_pfb, 'DDC4': fqlist_ddc, 'DDC8': fqlist_ddc }
make_fqlist = choice(fqlist_fn.__contains__, fqlist_fn.__getitem__, 
                     compose(Raise, RuntimeError, "No make_fqlist for firmware {0}".format))


#################################################
# describe a setup from the VEX file
#################################################
class Setup(object):
    __slots__ = ['setup', 'mode', 'channels', 'track_frame_format', 'dbes_used']

    def __init__(self, **kwargs):
        reduce(lambda acc, attr: setattr(acc, attr, kwargs.pop(attr, None)) or acc, Setup.__slots__, self)
        self.dbes_used = set()

    def __repr__(self):
        return "Setup: {0.setup} [{0.mode}] {0.datarate}Mbps {0.track_frame_format} ".format(self) + self.firmware + \
               "\n\t".join([""]+map(repr, [] if not self.channels else self.channels))

    @property
    def firmware(self):
        if self.channels is None:
            return None
        return "PFB" if len(self.channels)>8 else ("DDC4" if len(self.channels)<=4 else "DDC8")

    @property
    def datarate(self):
        # sum all bandwidths (units in MHz), multiply by 2 on account of Nyquist
        return 2 * int(sum(map(GetA('bw'), [] if self.channels is None else self.channels)))

    @property
    def procedures(self):
        Assert(self.channels is not None, "No channels defined for setup {0}".format(self.setup))
        # generate the procedure text
        # FIXME TODO XXX    need to do ifread/bbcread depending on firmware!
        return [Procedure(self.setup, make_fqlist(self.firmware)(self))]# + [] if self.firmware

    @property
    def nChannel(self):
        if self.channels is None:
            raise RuntimeError("No channels defained for setup {0}".format(self.setup))
        return len(self.channels)


class Channel(object):
    __slots__ = ['bbc', 'abcd', 'pol', 'lo', 'sb', 'if_sb', 'pcal', 'bw', 'freq', 'ch_ref']

    def __init__(self, **kwargs):
        reduce(lambda acc, attr: setattr(acc, attr, kwargs.pop(attr, None)) or acc, Channel.__slots__, self)

    canon_pcal   = property(compose(canon_pcal_f, GetA('pcal')))
    canon_sb     = property(compose(canon_sb_f, GetA('sb')))
    canon_if_sb  = property(compose(canon_sb_f, GetA('if_sb')))
    canon_if     = property(compose(canon_if_f, GetA('abcd')))
    canon_pol    = property(compose(canon_pol_f, GetA('pol')))
    pcal_state   = property(compose(pcal_state_f, GetA('pcal')))

    __hash__     = method(GetA('bbc'))
    __repr__     = method("BBC{0.bbc:02d}: {0.bw:.2f}MHz@{0.freq:.2f} [LO={0.lo:.2f}MHz] {0.sb} {0.pol} pcal:{0.pcal}".format)


# input: - ("mode", ("setupXX", { 'BBC': "BBC-def", 'IF': "IF-def", ... ) 
#        - vex object
# transform to:
#          ("mode", Setup(setup="setupXX", procedure="define setupXX 0000000x\n .... enddef\n", firmware="..."))
def resolve_mode(vexobj):
    def do_resolve(acc, mode):
        # destructure the mode "(key, value)" item, where value = "(setup, {})"
        (modename, (setupname, setup)) = mode

        # Transform the BBC_assign entries into lookuptable {BBCref: (BBCnum, IFref), ...}
        bbc_lut = mk_vex_lut('BBC', setup['BBC'], 'BBC_assign')(vexobj)
        if_lut  = mk_vex_lut('IF' , setup['IF'] , 'if_def')(vexobj)

        # Can already construct the actual setup object
        nSetup = Setup(mode=modename, setup=setupname, channels=list(),
                       track_frame_format=vexobj['TRACKS'][setup['TRACKS']]['track_frame_format'])

        # Loop over all defined frequency channels, collect important frequency, lo info
        for fqchan in vexobj['FREQ'][setup['FREQ']].getall('chan_def'):
            (_, ch_freq, sb, bw, ch_ref, bbc_ref, nix) = fqchan
            (bbc_num, if_ref)                     = bbc_lut[ bbc_ref ]
            (ABCD, if_pol, if_lo, if_sb, if_pcal) = if_lut[ if_ref ]
            nSetup.channels.append( D(Channel(bbc=int(bbc_num), abcd=ABCD, pol=if_pol, lo=fltMHz(if_lo), ch_ref=ch_ref,
                                              sb=sb, if_sb=if_sb, pcal=fltMHz(if_pcal), bw=int(fltMHz(bw)), freq=fltMHz(ch_freq))) )

        # insert new setup into accumulator
        #print(nSetup.procedure)
        return setitem_(modename, nSetup)(acc)
    return do_resolve


# basic procedures

exper_name   = compose(GetN('exper_name'), GetN(1), next, Call('iteritems'), GetN('EXPER'))
EXPER, exper = (compose(str.upper, exper_name), compose(str.lower, exper_name) )
NominalStart = compose(mk_vextime, GetN('exper_nominal_start'), GetN(1), next, Call('iteritems'), GetN('EXPER'))

def proc_library(vexfile, userinp):
    # extract station/site info for the given station
    station = mk_station(vexfile, userinp.station)
    return Procedure("proc_library", mk_lines(
    """ " {experiment} {SITE} {station}\n
     " vex2snap/Python version {version} by Harro Verkouter, JIVE\n
     " based on vex2snap version 2014_nov_06 by DG and UB, MPIfR\n
     "< {RACK}  rack>< {recorder: <10s}recorder 1>< None    recorder 2>""".format(
             experiment=EXPER(vexfile), station=userinput.station,
             SITE=station.site.site_name, RACK=station.das.electronics_rack_type,
             recorder=str(userinput.recorder or station.das.record_transport_type), **globals())), initial_newline="")

def exper_init(vexfile, userinp):
    return Procedure("exper_initi", mk_lines("proc_library\nsched_initi\n"))

def sched_init(vexfile, userinp):
    return Procedure("sched_initi")

standard_procedures = Pam(proc_library, exper_init, sched_init)

def process_setup(acc, setup):
    return reduce(lambda a, p: (a[p].append(p.lines) or a) if p in a else setitem_(p, p)(a), setup.procedures, acc)

def snap_header(vexfile, userinp):
    # extract station/site info for the given station
    station   = mk_station(vexfile, userinp.station)
    # extract experiment nominal start
    nom_start = NominalStart(vexfile)
    return comment("""
    {experiment} {nom_start.y} {SITE} H {userinp.station}\n
    H {SITE} AZEL sss  s s s s s s s  {userinp.station}\n
    {userinp.station} {SITE} {station.site.site_position_snap}\n
    vex2snap/Python version {version} by Harro Verkouter, JIVE\n
      based on vex2snap version 2014_nov_06 by DG and UB, MPIfR\n
    Rack={station.das.electronics_rack_type}  Recorder 1={recorder}  Recorder 2=none""".format(version=version,
             experiment=EXPER(vexfile), SITE=station.site.site_name,
             recorder = str(userinput.recorder or station.das.record_transport_type), **locals()))

# ordered dict with a tiny twist -
# the key will always be hash(key) such that 
# the elements can be indexed by Procedure() or by "name" -
# hash(Procedure) returns hash(self.name)
class MOrderedDict(collections.OrderedDict):
    def __setitem__(self, key, *args, **kwargs):
        return collections.OrderedDict.__setitem__(self, hash(key), *args, **kwargs)

    def __getitem__(self, key, *args, **kwargs):
        return collections.OrderedDict.__getitem__(self, hash(key), *args, **kwargs)

    def __delitem__(self, key, *args, **kwargs):
        return collections.OrderedDict.__delitem__(self, hash(key), *args, **kwargs)

# input:  dict{ "mode":Setup(), "mode":Setup(), ... }
# output: [Setup(), Setup(), ...] ordered by setup name "setup01", "setup02", ...
ordered_setups = compose(Sorted(key=compose(int_key("^setup(\d+)"), GetA('setup'))), Map(GetN(1)), Call('iteritems'))

#############################################################
#        do the work of processing the vex file
#############################################################
def process_vex(vexfile):
    with OpenVex(vexfile) as vexf:
        # extract station information
        station = mk_station(vexf, userinput.station)

        # get the time-shifting function
        t_shift = userinput.utc_shift( vexf )

        # Generate the output file names: destination/<exper><station>.{snp, prc, lst}
        files   = output_files(vexf, userinput.station)
        # check if they exist and if so if ok to overwrite
        ok_to_write(files)

        # figure out which scans the station should observe
        # we do not extract the scan object(s) from the vexfile yet because
        # we need to retain the order of the scans (if we created a dict { "scanLabel":<scanObject> }
        # we could loose the order of scan label. There is no guarantee scan labels contain any useful information.
        scans  = get_station_scans(userinput.station)( vexf )

        Assert(scans, "The station '{0}' does not observe any of the scans".format(userinput.station))

        # Convert all mode names to a dict of {"mode", ("setupXX", {'BBC': <BBC-defname>, 'IF': <IF-defname>, ..}), ... }
        # with the defnames appropriate for the selected station
        modes  = compose(partial(refs_for_station, userinput.station), Map(enumerate_setups), Map(get_mode(vexf)),
                         Call('iterkeys'), GetN('MODE'))(vexf)

        # Transform that dict to { "mode": Setup(...), "mode":Setup(...), ... }
        setups = reduce(resolve_mode(vexf), modes.iteritems(), dict())

        # We want the procedures to be ordered - at least some of them
        procedures = MOrderedDict()#collections.OrderedDict()

        for proc in standard_procedures(vexf, userinput):
            procedures[proc] = proc
        
        # Now go over the setups - each may yield a list of (new) procedures they have 
        # or existing procedures they have to add stuff to
        # Note: setups = { "mode":Setup(), ... }
        #  But: we want the setups ordered by "setup01", "setup02", ...
        #   So: extract all Setup() objects and sort by name
        procedures = reduce(process_setup, ordered_setups(setups), procedures)

        # todo: 
        # procedure collect - tsys
        #           start   - initiate collect every 10s
        #           preob   - ifread/dbe_quanttize_hold_set
        collect, start, preob = map(Procedure, ["collect", "start", "preob"])

        procedures[preob]   = preob
        procedures[start]   = start
        procedures[collect] = collect

        # Now that all setups (and thus modes) have been generated,
        procedures[preob].append( "ifread" )
        procedures[start].append( "collect@!,10s" )

        # we can extract the set of all dbe's ever used in all setups
        # so we can properly add initialization commands for all used dbe's to
        # the appropriate procedures
        for dbe in get_all_dbes(setups):
            # XXX TODO FIXME
            # ifread for all firmwares
            #  bbcread for DDC4, + bbcread2 for DDC8
            #  dbe_quantize=hold_set for PFB
            for p, lst in [(preob, ["rdbe_cmd={dbe},3,dbe_quantize=hold_set;".format]),
                    ("sched_initi", ["rdbe_cmd={dbe},3,dbe_data_send=on;".format,
                                     "rdbe_time={dbe},3".format, 
                                     "rdbe_cmd={dbe},3,dbe_dot?;".format])]:
                for cmd in lst:
                    procedures[p].append( cmd(**locals()) )

        procedures["sched_initi"].append( "!+1s\ngetgps\n!+1s\nready_disk" )
        procedures[preob].append( "op_stream=start" )

        # tsys is collected per RDBE input
        for dbe_inp in get_all_inputs(setups):
            collect.append( "rdbe_tsys={dbe_inp[0]},{dbe_inp[1]}".format(**locals()) )

        # If there is a recorder defined, it will be jive5ab so let's ask it for its version &cet
        recorder = (userinput.recorder or station.das.record_transport_type)
        for p in [] if recorder is None else recorder.procedures():
            procedures[p].append( p.lines )

        # Now need to go over all setups and configure the recorder "mode=" and "net_protocol="
        #           setupN  - recorder config? 
        for setup in setups.values():
            for p in recorder.setup_procedures(setup):
                procedures[p].append( p.lines )

        # TODO XXX FIXME
        # read /usr2/control/rdbead.ctl for rdbe address and tsys/1pps monitoring

        # get the lookuptable from SOURCE-def => Source()
        sources = source_lut(vexf)

        # Now that we're sure we got everything, open the files and start writing
        (into_snp, into_prc, into_lst) = map(compose(GetA('write'), partial(open, mode='w'), MSG("Writing")), files)

        for p in procedures.values():
            into_prc(str(p))

        # produce .snp file with all scans in
        #   do the .snp header
        into_snp("\n".join(snap_header(vexf, userinput)))

        # loop over all scans for the station
        setup           = None
        prev_end_time   = 0
        experiment_snap = exper( vexf )
        station_snap    = userinput.station.lower()

        for scan in scans:
            # start with empty line to make sure we first append nothing to previous written line
            # and then issue a newline to start on the next one
            scanLines = [""]

            # allow recorders to send some initialization commands?
            if not prev_end_time:
                scanLines.extend( recorder.ready_disk() )

            # if there was a previous scan and there's
            # there's time for postob+checkmk5 then insert that
            if prev_end_time and (scan.start - prev_end_time)>=20:
                scanLines.extend( mk_lines("postob\ncheckmk5") )

            source = sources[scan.source] 
            scanLines.extend( mk_lines("""
                    scan_name={scan.label_snap},{experiment_snap},{station_snap},{scan.duration},{scan.duration}\n
                    source={scan.source},{source.ra_snap},{source.dec_snap}\n""".format(**locals())))

            # switch to setup for current scan if different
            scan_setup = setups[scan.mode].setup
            if setup != scan_setup:
                scanLines.append( scan_setup )
                setup = scan_setup
            
            # is there time for pre-ob?
            preob_time = scan.nominal_start.seconds-10
            if preob_time>=prev_end_time:
                scanLines.extend( mk_lines("!{preob_time}\npreob".format(preob_time=sec2fstime(preob_time))) )

            # wait for scan start and then switch on recording
            scanLines.append( "!{scan.nominal_start.as_fstime}".format(**locals()) )
            scanLines.extend( recorder.record_on(scan) )
            # insert a midob + wait for end of scan
            scanLines.extend( mk_lines("midob\n!{scan.nominal_end.as_fstime}".format(**locals())) )
            # switch off the recording
            scanLines.extend( recorder.record_off(scan) )
            into_snp("\n".join(scanLines))
            prev_end_time = scan.end

        # If we did observe at least one scan, finish off with a final postob/checkmk5
        if prev_end_time:
            into_snp("\npostob\ncheckmk5")
        # and trigger sched_end
        into_snp("\nsched_end")
    return None

###################################################################################################
#
#         main loop: iterate over all vexfiles given
#
###################################################################################################
main = Map(compose(process_vex, MSG("Start processing")))

main(userinput.vexfiles)
