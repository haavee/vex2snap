#!/usr/bin/env python
# 
# vex2snap -- convert from VEX file to .snp, .prc file, replacing DRUDG
#             for RDBE PFB/DDC + Mark5C/Mark6 [running jive5ab] combo
#
#   Usage:  vex2snap [options] --station XX [vex1 [vex2 [...]]
#           see 'vex2snap --help' for [options]
#
#   Options:
#            --help             show short help
#            --usage            show this built-in help
#            --version          print version and exit succesfully
#            --dest             set destination path for output files
#                               [default: /usr2/sched]
#            --force            overwrite output files [default: don't!]
#            --ignore-utc       do not forget scans from the past
#                               [default: only process scheduled scans
#                               that are still observable - i.e. in the future]
#
#   Description:
#
#   vex2snap reads the vex file(s) and extracts the useful information for the
#   station indicated by XX. It starts by analyzing the scans where this station
#   is in and extracting the necessary setups for those.
#
#   Based on that information a .prc file with initialization and setup
#   procedures is created. A snap file containing the actions for the whole
#   experiment is also output.
#
#        xxx.vex => /usr2/sched/xxx.{prc,snp}  [default output path]
#            Note: if the output file(s) already exist, the program halts.
#                  This behaviour can be overridden through the --force option
#  
#
from __future__ import print_function
import re, os, sys, copy, argparse, itertools, datetime
from functools import reduce, partial
from operator import *
from vex.vex import Vex

##########################################################################################
version = "0.01"


################## These should be standard .... #########################################
compose     = lambda *fns   : (lambda x: reduce(lambda acc, f: f(acc), reversed(fns), x)) # f[0]( f[1]( .. (x) ))
choice      = lambda p, t, f: (lambda x: t(x) if p(x) else f(x))  # branch
ylppa       = lambda x      : (lambda f: f(x))                    # ylppa is 'apply' in reverse ...
combine     = lambda f, *fns: (lambda x: f(*map(ylppa(x), fns)))  # f( fn[0](x), fn[1](x), ... )
method      = lambda f      : (lambda *args, **kwargs: f(*args, **kwargs))
swap_args   = lambda f      : (lambda a, b, *args, **kwargs: f(b, a, *args, **kwargs))
logic_or    = lambda x, y   : x or y                              # operator.__or__ / __and__ are /bitwise/ ops!
logic_and   = lambda x, y   : x and y                             #               ..
const       = lambda x      : (lambda _: x)                       # return the same value irrespective of input
identity    = lambda x      : x                                   # probably the most undervalued operator
between     = lambda a, b   : (lambda x: a<=x<b)                  # missing from module 'operator'?
m_itemgetter= lambda *idx   : (lambda x: map(x.__getitem__, idx)) # _ALWAYS_ returns [...], irrespective of #-of-indices
                                                                  #   for laughs, look up 'operator.itemgetter()' => 3 (three!)
                                                                  #   different types of return type depending on arguments! FFS!
# reorder_args: call f with the arguments indicated by idx:
# call f with args[idx[n]] for 0 <= n < len(idx)
# f will be called with len(idx) arguments. can also be used to select/repeat arguments
reorder_args= lambda f, *idx: (lambda *args, **kwargs: f(*m_itemgetter(*idx)(args), **kwargs))
hasattr_    = lambda a      : partial(reorder_args(hasattr, 1, 0), a)
getattr_    = lambda a      : partial(reorder_args(getattr, 1, 0), a)
# it is "setattr(o, a, v)" but we call it as "setattr_(a, v)(o)" thus a,v,o needs to be reorderd to o, a, v, i.e. 2,0,1
# note that setattr_ returns the object itself so it can be chained
setattr_    = lambda a, v   : combine(logic_or, partial(reorder_args(setattr, 2, 0, 1), a, v), identity)
delattr_    = lambda a      : combine(logic_or, partial(reorder_args(delattr, 1, 0), a), identity)
Map         = lambda f      : partial(map, f)
StarMap     = lambda f      : partial(itertools.starmap, f)
Pam         = lambda *fns   : (lambda x: map(lambda f: f(x), fns))
Filter      = lambda f      : partial(filter, f)
Reduce      = lambda f, *a  : partial(reduce, f, *a)
Zip         = lambda l      : (lambda x: zip(l,x))
Type        = lambda **kwargs  : type('', (), kwargs)
is_none     = partial(is_, None)
GetN        = itemgetter
GetA        = attrgetter
Call        = methodcaller
# head, tail on lists might be useful!
head        = GetN(0)
tail        = GetN(slice(1,None))

def Raise(x):
    raise x
def Error(f):
    def do_it(x):
        raise RuntimeError(f(x))
    return do_it
Assert  = lambda x, *args, **kwargs: Raise(AssertionError(*args, **kwargs)) if not x else None
AssertF = lambda f, *args, **kwargs: (lambda x: Assert(f(x), *args, **kwargs))

def MSG(pfx = None):
    fmt = ("{0}" if pfx is None else pfx+": {0}").format
    def print_it(x):
        print(fmt(x))
        return x
    return print_it

# filterWith - a filter that acts as "sorted(..., key=fn)
# i.e. filter input based on a predicate on item in stead of on the item
def filterWith(predicate):
    def do_filter(inp):
        result = []
        for item in inp:
            predicate(item) and result.append( item )
        return result
    return do_filter

# this implementation is not the shortest partition() but it is the fastest
#  (pred, list) => (true_list, false_list)
def partition(pred, l):
    ltrue, lfalse = (list(), list())
    for item in l:
        (ltrue if pred(item) else lfalse).append( item )
    return (ltrue, lfalse)
Partition = lambda pred: (lambda l: partition(pred, l))

###################################################
#       Some time-related functionality
###################################################

# convert any sequence of (doy, hh, mm, ss) into seconds-within-year
yhms2sec    = compose(sum, StarMap(mul), Zip([86400, 3600, 60, 1]), Map(int))
# extract those values from an utctimetuple()
utsec_year  = compose(yhms2sec, GetA('tm_yday', 'tm_hour', 'tm_min', 'tm_sec'), Call('utctimetuple'))
# extract them from a VEX time stamp 
vextime2sec = compose(yhms2sec, Call('groups'), re.compile(r"^\d+y(\d+)d(\d+)h(\d+)m(\d+)s$").match,
                      partial(re.sub, r"[ \t\n]*", r""))
utcsec_now  = utsec_year( datetime.datetime.utcnow() )


#############################################################################
#
#                      Commandline parsing
#
#############################################################################
class PrintHelp(argparse.Action):
    def __call__(self, the_parsert, *args):
        the_parsert.print_help() or sys.exit( 0 )

arg0_or_zero = choice(truth, itemgetter(0), const(0))
def usage(*args):
    # http://stackoverflow.com/a/1676860
    import pydoc, inspect
    # extract the documentation at the top of this module, put it through pydoc.pager and then exit :-)
    return compose(const(arg0_or_zero(args)), pydoc.pager, inspect.getcomments, itemgetter(__name__))(sys.modules)

class PrintUsage(argparse.Action):
    def __call__(self, the_parsert, *args):
        sys.exit( usage() )


parsert = argparse.ArgumentParser(description="Transform VEX files to .snp/.prc", add_help=False)
parsert.add_argument('--help',   nargs=0, action=PrintHelp, help="Show this help message and exit succesfully")
parsert.add_argument('--usage',  nargs=0, action=PrintUsage, help="Show built-in usage")
parsert.add_argument('--debug',  dest='debug', action='store_true', default=False, 
                     help="Print debugging information")
parsert.add_argument('--version', action='version', version=version, help="Print current version and exit succesfully")
parsert.add_argument('--dest', dest='output_path', type=str, default="/usr2/sched",
                     help="Location where to store output .prc/.snp files")
parsert.add_argument('--force', dest='file_exists', action="store_const", const=const(False), default=os.path.isfile,
                     help="Overwrite existing output files (default: don't)")
parsert.add_argument('--station', dest='station', type=str, required=True,
                     help="The station two-letter-codefor which to generate the .prc/.snp files")
parsert.add_argument('--ignore-utc', dest="utc_limit", default=utcsec_now, action="store_const", const=0,
                     help="Ignore current UTC time - i.e. just process all scans even when they cannot be observed anymore")
parsert.add_argument("vexfile", nargs='*', help="One or more vexfiles to process")

###################################
# Actually parse the command line #
###################################
userinput = parsert.parse_args()

# Take some actions based on what the user gave us (debug e.g.)
if userinput.debug:
    D  = MSG("DEBUG")
    DD = lambda y: MSG(y)
else:
    D  = identity
    DD = const(identity)
    def silent_except_hook(tp, val, tb):
        print(str(val))
    sys.excepthook = silent_except_hook

#################################################################################################
#
#                 Handle a single vex file
#
#################################################################################################
fileExists = choice(os.path.isfile, identity, compose(Raise, RuntimeError, partial(add, "File does not exist: ")))

# transform /path/to/file.vex => file
#  .split() => (/path/to, file.vex)
#  .splitext() => (file, vex)
vexName    = compose(GetN(0), os.path.splitext, GetN(1), os.path.split)

# input: vexfile name, output: functions generating the names of the output file(s) given a station
fn_func      = lambda ext: (lambda base: compose("{0}{{0}}.{1}".format(base.lower(), ext.lower()).format, str.lower))
add_prefix   = partial(os.path.join, userinput.output_path)
output_files = lambda vexobj, station: compose(DD("Output files"), Map(compose(add_prefix, ylppa(station))),
                                               Pam(*map(fn_func, ['snp', 'prc', 'lst'])),
                                               str.lower, next, Call('iterkeys'), GetN('EXPER'))(vexobj)

# we map the userinput.file_exists function over the files and if any of those is true 
# raise an error
ok_to_write  = compose(choice(truth,
                              compose(Raise, const(RuntimeError("Output file(s) exist. Use --force to forcibly overwrite"))),
                              identity),
                       any, list, Map(userinput.file_exists))


###############################################################################
#
#                      Dealing with vex content
#
###############################################################################

# wrapper to turn opening a vex file into a context so 
# this works: 
#    with OpenVex(filename) as vexf: 
#        <stuff with vexf>
class OpenVex(object):
    def __init__(self, filename):
        self.filename = filename
    def __enter__(self):
        self.vex = Vex(self.filename)
        return self.vex
    def __exit__(self, e, t, f):
        return

vexyear     = compose(GetN(0), Map(int), Call('groups'),
                      re.compile(r"^(\d+)y\d+d\d+h\d+m\d+s$").match, partial(re.sub, r"[ \t\n]*", r""))

def s2v_r(acc, x):
    (whole, remain) = divmod(acc.time, x[0])
    acc.time_s     += x[1](whole)
    acc.time        = remain
    return acc
sec2vextime = compose(GetA('time_s'), AssertF(compose(not_, GetA('time')), "Non-integer second time stamp is unacceptable"),
                      Reduce(s2v_r, [(86400, "{0}d".format), (3600, "{0:02d}h".format),
                                     (60, "{0:02d}m".format), (1, "{0:02d}s".format)]),
                      lambda x: Type(time_s="", time=x))
intSec      = compose(int, str.strip, partial(re.sub, r"s(ec)?", r""))


class Scan(object):
    __slots__ = ['mode', 'label', 'nominal_start', 'source', 'offset', 'duration', 'year']

    # initialize from keywordargs
    def __init__(self, **kwargs):
        reduce(lambda acc, attr: setattr(acc, attr, kwargs.pop(attr, None)) or acc, Scan.__slots__, self)
        Assert(self.duration>self.offset, "Attempt to observe scan where data-good > scan duration")

    @property
    def start(self):
        return self.nominal_start + self.offset
    @property
    def end(self):
        return self.nominal_start + self.duration


def station_scan(station):
    # scan == (scanId, <vex scan obj>)
    def station_observes(scan):
        (scanId, scanObj) = scan
        #station=Eb:    0 sec:  620 sec:   42.961 GB:   :       : 0;
        #        0      1       2          3               4      5
        station_line      = filter(compose(partial(eq, station), GetN(0)), scanObj.getall('station'))
        station_line      = station_line[0] if station_line else None
        if not station_line:
            return None
        return Scan(mode=scanObj['mode'], nominal_start=vextime2sec(scanObj['start']),
                    source=scanObj['source'], offset=intSec(station_line[1]), label=scanId,
                    year=vexyear(scanObj['start']), duration=intSec(station_line[2]))
    return station_observes

# Filter the list of scans for the indicated station and also
# filter out the ones that are in the past
end_in_future     = compose(partial(lt, userinput.utc_limit), DD("scan-end"), GetA('end'))
get_station_scans = lambda station: compose(Filter(end_in_future), Filter(truth), Map(station_scan(station)), Call('iteritems'), GetN('SCHED'))

# From a MODE extract the IF, FREQ, BBC, TRACKS, PHASE_CAL_DETECT for the requested station.
# In the VEX file these are ref lines so format is:
#   ref $REF = <defname> : station : station : ... ;
#   ref $REF = <defname> : station : station : ... ;
#
#   mode.iteritems() gives us a sequence of:
#      [ (REF-name, [<defname>, station, station, ...]),
#        (REF-name, [<defname>, station, station, ...], .. ]
# So we filter the required REF-name's that we need, keeping only the entry
# where the requested station is in the list of stations following the <defname>.
# 
# Eventually we produce a dict with entries like this:
#       {"mode": ("setupXX", <mode-for-station>)}
# 
#  where <mode-for-station> == { 'BBC': "defname>, 'IF': "defname", ... }


# extract <vexfile>['MODE'][mode] <object> and set <object>.mode = "mode"
get_mode         = lambda vexobject: lambda mode: compose(setattr_('mode', mode), GetN(mode), GetN('MODE'))(vexobject)
# set <mode object>.setup = "setupXX", auto-counting from 1
enumerate_setups = lambda mode, cnt=itertools.count(1): setattr_('setup', "setup{0:02d}".format(next(cnt)))(mode)
# Which ref lines we need and how to tell which one applies to a particular station
needed_refs      = set(['IF', 'FREQ', 'BBC', 'TRACKS', 'PHASE_CAL_DETECT'])
is_for_station   = lambda station  : lambda l: l[0] if station in l[1:] else None
refs_for_station = lambda st, modes: reduce(lambda acc, mode:
                                     acc.update( {mode.mode:(mode.setup,
                                                             compose(dict, Map(compose(tuple, Pam(GetN(0), compose(GetN(0), GetN(1))))),
                                                                     Filter(compose(is_for_station(st), GetN(1))),
                                                                     Filter(compose(needed_refs.__contains__, GetN(0))),
                                                                     list, Call('iteritems'))(mode)) } ) or acc, modes, dict())

###############################################################################
##    moving on to decoding
###############################################################################

mk_vex_lut = lambda sect, defname, key:compose(DD("VEX lut[{0}.{1}".format(sect,defname)), dict, Map(Pam(head, tail)),
                                               Call('getall', key), GetN(defname), GetN(sect))

# shorthands for converting vex file values to canonical things
fltMHz     = choice(truth, compose(float, str.strip, partial(re.compile(r'[ \t]*MHz').sub, "")), const(None))
sideband_  = { 'U': 'usb', 'L': 'lsb' }
canon_sb   = compose(sideband_.__getitem__, str.upper)
canon_pol  = str.lower
canon_if   = str.lower
pcal_state = choice(is_none, const("pcaloff"), const("pcalon"))
canon_pcal = choice(is_none, const("off"), int)
# there is a mapping of IF_A/B => input 0 and C/D to 1
inp_zero   = "AaBb"
inp_one    = "CcDd"
if_to_inp  = choice(inp_zero.__contains__, const(0),
                    choice(inp_one.__contains__, const(1),
                           Error("No known mapping for IF{0} to RDBE input".format)))

pfb_split  = compose(enumerate, Filter(truth), Partition(lambda x: x.sb == 'lsb'))
#chet's 'upper edge' table, modified to add 1024, leave out 528
# (verbatim from vex2snap.pl)
chet_fh    = [1024,1008,976,944,912,880,848,816,784,752,720,688,656,624,592,560];
lookup_fh  = choice(chet_fh.__contains__, chet_fh.index, Error("Unmapped PFB channel frequency {0}".format))
#mk_ifcnt   = lambda: {0:itertools.count(), 1:itertools.count()}

###############################################################################
#
#  Process the channels based on deduced type of firmware
#  and generate the RDBE procedure
#
###############################################################################
def fqlist_pfb(channels):
    # put all channels of one kind of sideband in one DBE, filter out
    # ones that don't have channels and enumerate the resulting channel lists
    dbes, fqs = (list(), list())
    los       = dict()
    rdbe_los  = dict()
    pcal_s    = set()  # set of pcal states, can assert we only have one

    for dbe, ch_list in pfb_split(channels):
        # must clear the rdbe
        dbes.append( "rdbe_person=dbe{dbe},pfb".format(dbe=dbe) )
        dbes.append( "rdbefclr=dbe{dbe}".format(dbe=dbe) )
        # count channels per IF
        for (chan, ch) in enumerate(ch_list, start=1):
            Assert(chan<=16, "Cannot do more than 16 channels per RDBE input")
            # convert channel properties to stuff we need
            ch_frq = int(ch.freq - ch.lo)
            iif    = if_to_inp(ch.abcd)
            # Get current pcal state
            pcal_s.add( pcal_state(ch.pcal) )
            # did we set the LO for this (IF,input)?
            loc    = "lo{0}".format( ch.abcd.lower() )
            if (loc, iif) not in los:
                los[(loc, iif)]      = "lo="+loc+",{ch.lo:.2f},{ch.sb},{ch.pol}cp,{pcal}".format(ch=ch, pcal=canon_pcal(ch.pcal))
                rdbe_los[(loc, iif)] = "rdbe_if="+loc+",{ch.lo:.2f},{ch.sb},{ch.pol}cp,dbe{dbe},if{iif}".format(ch=ch, dbe=dbe, iif=iif)
            # Append a line describing this channel
            fqs.append( "rdbef{chan:02d}=dbe{dbe},if{iif},{ch.freq:.2f},{ch.bw},{ch.sb},{ch.pol},{ich}".format(
                        dbe=dbe, chan=chan, iif=iif, ch=ch, ich=lookup_fh(abs(ch_frq))) )

    # assert there's only one pcal state
    Assert(len(pcal_s)==1, "Inconsistent PCAL states - more than one found")
    return los.values()+dbes+fqs+rdbe_los.values()

def fqlist_ddc4(channels):
    return []

def fqlist_ddc8(channels):
    return []

# lookup table
fqlist_fn   = {'PFB': fqlist_pfb, 'DDC4': fqlist_ddc4, 'DDC8': fqlist_ddc8 }
make_fqlist = choice(fqlist_fn.__contains__, fqlist_fn.__getitem__, 
                     compose(Raise, RuntimeError, "No make_fqlist for firmware {0}".format))


#################################################
# describe a setup from the VEX file
#################################################
class Setup(object):
    __slots__ = ['setup', 'mode', 'channels', 'track_frame_format']

    def __init__(self, **kwargs):
        reduce(lambda acc, attr: setattr(acc, attr, kwargs.pop(attr, None)) or acc, Setup.__slots__, self)

    def __repr__(self):
        return "Setup: {0.setup} [{0.mode}] {0.datarate}Mbps {0.track_frame_format} ".format(self) + self.firmware + \
               "\n\t".join([""]+map(repr, [] if not self.channels else self.channels))

    @property
    def firmware(self):
        if self.channels is None:
            return None
        return "PFB" if len(self.channels)>8 else ("DDC4" if len(self.channels)<=4 else "DDC8")

    @property
    def datarate(self):
        # sum all bandwidths (units in MHz), multiply by 2 on account of Nyquist
        return 2 * int(sum(map(GetA('bw'), [] if self.channels is None else self.channels)))

    @property
    def procedure(self):
        Assert(self.channels is not None, "No channels defined for setup {0}".format(self.setup))
        # generate the procedure text
        return Procedure(self.setup, make_fqlist(self.firmware)(self.channels))





####################################################
#  A snap procedure
####################################################
class Procedure(object):
    def __init__(self, name, init_list=None):
        # at most 12 characters in procedure name
        Assert(len(name)<=12, "SNAP procedure name '{0}' is longer than 12 characters".format(name))
        self.name  = name
        self.lines = copy.deepcopy(init_list if init_list is not None else list())

    def append(self, line):
        self.lines.append(line)
        return self

    def __str__(self):
        return "\ndefine  {0: <12s} 00000000000x\n".format(self.name) + "\n".join(self.lines)+"\nenddef"

# input: - ("mode", ("setupXX", { 'BBC': "BBC-def", 'IF': "IF-def", ... ) 
#        - vex object
# transform to:
#          ("mode", Object(setup="setupXX", procedure="define setupXX 0000000x\n .... enddef\n", firmware="..."))
def resolve_mode(vexobj):
    def do_resolve(acc, mode):
        # destructure the mode "(key, value)" item, where value = "(setup, {})"
        (modename, (setupname, setup)) = mode

        # Transform the BBC_assign entries into lookuptable {BBCref: (BBCnum, IFref), ...}
        bbc_lut = mk_vex_lut('BBC', setup['BBC'], 'BBC_assign')(vexobj)
        if_lut  = mk_vex_lut('IF' , setup['IF'] , 'if_def')(vexobj)

        # Can already construct the actual setup object
        nSetup = Setup(mode=modename, setup=setupname, channels=list(),
                       track_frame_format=vexobj['TRACKS'][setup['TRACKS']]['track_frame_format'])

        # Loop over all defined frequency channels, collect important frequency, lo info
        for fqchan in vexobj['FREQ'][setup['FREQ']].getall('chan_def'):
            (_, ch_freq, sb, bw, ch_ref, bbc_ref, nix) = fqchan
            (bbc_num, if_ref)                     = bbc_lut[ bbc_ref ]
            (ABCD, if_pol, if_lo, if_sb, if_pcal) = if_lut[ if_ref ]
            nSetup.channels.append( Type(bbc=int(bbc_num), abcd=ABCD, pol=canon_pol(if_pol), lo=fltMHz(if_lo),
                                         sb=canon_sb(if_sb), pcal=fltMHz(if_pcal), bw=fltMHz(bw), freq=fltMHz(ch_freq),
                                         __repr__ = method("BBC{0.bbc:02d}: {0.bw:.2f}MHz@LO={0.lo:.2f}MHz {0.sb}{0.pol} pcal:{0.pcal}".format))() )
        print(nSetup.procedure)
        #
    return do_resolve

#############################################################
#        do the work of processing the vex file
#############################################################
def process_vex(vexfile):
    with OpenVex(vexfile) as vexf:
        # Generate the output file names: destination/<exper><station>.{prc, snp, lst}
        files = output_files(vexf, userinput.station)
        # check if they exist and if so if ok to overwrite
        ok_to_write(files)

        # figure out which scans the station should observe
        # we do not extract the scan object(s) from the vexfile yet because
        # we need to retain the order of the scans (if we created a dict { "scanLabel":<scanObject> }
        # we could loose the order of scan label. There is no guarantee scan labels contain any useful information.
        #scans = filter(station_scan(userinput.station), vexf['SCHED'].iteritems())
        scans = get_station_scans(userinput.station)( vexf )

        Assert(scans, "The station '{0}' does not observe any of the scans".format(userinput.station))

        # collect all mode names - they need to be converted into setups
        modes = compose(set, Map(GetA('mode')))(scans)
        #modes = reduce(lambda acc, scan: acc.add(scan_mode(scan)) or acc, scans, set())

        # Convert to a dict of {"mode", ("setupXX", {'BBC': <BBC-defname>, 'IF': <IF-defname>, ..}), ... }
        # with the defnames applicable to the desired names
        modes = compose(partial(refs_for_station, userinput.station), Map(enumerate_setups), Map(get_mode(vexf)))(modes)

        setups = reduce(resolve_mode(vexf), modes.iteritems(), {})

        procedure = Procedure("sched_")
        procedure.append('" BP229B EB_RDBE2 Eb')

        print("Scans: ", Map(GetA('label'))(scans))
        print("Modes: ", modes)
        print("Procedures:")
        print(procedure)
    return None

# main loop: iterate over all command line arguments
main = compose(process_vex, MSG("Start processing"))

map(main, userinput.vexfile)
