#!/usr/bin/env python
# 
# vex2snap -- convert from VEX file to .snp, .prc file, replacing DRUDG
#             for RDBE PFB/DDC + Mark5C/Mark6 [running jive5ab] combo
#
#   Usage:  vex2snap [options] --station XX [vex1 [vex2 [...]]
#           see 'vex2snap --help' for [options]
#
#   Options:
#            --help             show short help
#            --usage            show this built-in help
#            --version          print version and exit succesfully
#            --station          Two-letter station code to generate .prc/.snp for
#            --dest             set destination path for output files
#                               [default: /usr2/sched]
#            --force            overwrite output files [default: don't!]
#            --ignore-utc       do not forget scans from the past
#                               [default: only process scheduled scans
#                               that are still observable - i.e. in the future]
#
#   Description:
#
#   vex2snap reads the vex file(s) and extracts the useful information for the
#   station indicated by XX. It starts by analyzing the scans where this station
#   is in and extracting the necessary setups for those.
#
#   Based on that information a .prc file with initialization and setup
#   procedures is created. A snap file containing the actions for the whole
#   experiment is also output.
#
#        xxx.vex => /usr2/sched/xxx.{prc,snp}  [default output path]
#            Note: if the output file(s) already exist, the program halts.
#                  This behaviour can be overridden through the --force option
#  
#
from __future__ import print_function
import re, os, sys, copy, argparse, itertools, datetime, collections
from functools import reduce, partial
from operator import *
from vex.vex import Vex

##########################################################################################
version = "0.01"


################## These should be standard .... #########################################
compose     = lambda *fns   : (lambda x: reduce(lambda acc, f: f(acc), reversed(fns), x)) # f[0]( f[1]( .. (x) ))
choice      = lambda p, t, f: (lambda x: t(x) if p(x) else f(x))  # branch
ylppa       = lambda x      : (lambda f: f(x))                    # ylppa is 'apply' in reverse ...
combine     = lambda f, *fns: (lambda x: f(*map(ylppa(x), fns)))  # f( fn[0](x), fn[1](x), ... )
method      = lambda f      : (lambda *args, **kwargs: f(*args, **kwargs))
swap_args   = lambda f      : (lambda a, b, *args, **kwargs: f(b, a, *args, **kwargs))
logic_or    = lambda x, y   : x or y                              # operator.__or__ / __and__ are /bitwise/ ops!
logic_and   = lambda x, y   : x and y                             #               ..
const       = lambda x      : (lambda _: x)                       # return the same value irrespective of input
identity    = lambda x      : x                                   # probably the most undervalued operator
between     = lambda a, b   : (lambda x: a<=x<b)                  # missing from module 'operator'?
# our getitem_ always returns a tuple of value(s)
#   for laughs, look up 'operator.itemgetter()' => 3 (three!)
#   different types of return type depending on arguments! FFS!
getitem_    = lambda *n     : (lambda x: tuple(GetN(*n)(x)))#(lambda x: map(x.__getitem__, n)) #compose(tuple, partial(reorder_args(getitem, 1, 0), n))
setitem_    = lambda n, v   : combine(logic_or, partial(reorder_args(setitem, 2, 0, 1), n, v), identity)
# reorder_args: call f with the arguments indicated by idx:
# call f with args[idx[n]] for 0 <= n < len(idx)
# f will be called with len(idx) arguments. can also be used to select/repeat arguments
#reorder_args= lambda f, *idx: (lambda *args, **kwargs: f(*m_itemgetter(*idx)(args), **kwargs))
reorder_args= lambda f, *idx: (lambda *args, **kwargs: f(*getitem_(*idx)(args), **kwargs))
hasattr_    = lambda a      : partial(reorder_args(hasattr, 1, 0), a)
getattr_    = lambda a      : partial(reorder_args(getattr, 1, 0), a)
# it is "setattr(o, a, v)" but we call it as "setattr_(a, v)(o)" thus a,v,o needs to be reorderd to o, a, v, i.e. 2,0,1
# note that setattr_ returns the object itself so it can be chained
setattr_    = lambda a, v   : combine(logic_or, partial(reorder_args(setattr, 2, 0, 1), a, v), identity)
delattr_    = lambda a      : combine(logic_or, partial(reorder_args(delattr, 1, 0), a), identity)
Map         = lambda f      : partial(map, f)
StarMap     = lambda f      : partial(itertools.starmap, f)
Pam         = lambda *fns   : (lambda *x, **k: map(lambda f: f(*x, **k), fns))
Filter      = lambda f      : partial(filter, f)
Reduce      = lambda f, *a  : partial(reduce, f, *a)
Sorted      = lambda **kws  : partial(sorted, **kws)
GroupBy     = lambda f      : (lambda l: itertools.groupby(l, f))
Zip         = lambda l      : (lambda x: zip(l,x))
Slice       = lambda *args  : (lambda o: getitem(o, slice(*args)))
XformItem   = lambda n, f   : (lambda o: setitem_(n, f(o[n])))
Type        = lambda **kwargs  : type('', (), kwargs)
all_equal   = compose(lambda g: next(g, True) and not next(g, False), itertools.groupby)
#is_iterable = combine(logic_or, hasattr_('__iter__'), hasattr_('__getitem__'))
#listify     = choice(is_iterable, identity, lambda x: [x])
is_none     = partial(is_, None)
GetN        = itemgetter
GetA        = attrgetter
Call        = methodcaller
DDict       = collections.defaultdict
Apply       = lambda f, *args, **kwargs: (lambda x: f(x, *args, **kwargs))
# head, tail on lists might be useful!
head        = GetN(0)
tail        = GetN(slice(1,None))

def Raise(x):
    raise x
def Error(f):
    def do_it(x):
        raise RuntimeError(f(x))
    return do_it
Assert  = lambda x, *args, **kwargs: Raise(AssertionError(*args, **kwargs)) if not x else None
AssertF = lambda f, *args, **kwargs: (lambda x: Assert(f(x), *args, **kwargs))

def MSG(pfx = None):
    fmt = ("{0}" if pfx is None else pfx+": {0}").format
    def print_it(x):
        print(fmt(x))
        return x
    return print_it

# filterWith - a filter that acts as "sorted(..., key=fn)
# i.e. filter input based on a predicate on item in stead of on the item
def filterWith(predicate):
    def do_filter(inp):
        result = []
        for item in inp:
            predicate(item) and result.append( item )
        return result
    return do_filter

# this implementation is not the shortest partition() but it is the fastest
#  (pred, list) => (true_list, false_list)
def partition(pred, l):
    ltrue, lfalse = (list(), list())
    for item in l:
        (ltrue if pred(item) else lfalse).append( item )
    return (ltrue, lfalse)
Partition = lambda pred: (lambda l: partition(pred, l))


###################################################
#       An ordered default dict
###################################################
class OrderedDefaultDict(collections.OrderedDict):
    def __init__(self, default_factory=None, *args, **kwargs):
        self.default_factory = default_factory
        super(OrderedDefaultDict, self).__init__(*args, **kwargs)

    def __missing__(self, key):
        if self.default_factory is None:
            raise KeyError("Key '{0}' not found".format(key))
        self[key] = value = self.default_factory()
        return value

###################################################
#       Some time-related functionality
###################################################

# convert any sequence of (doy, hh, mm, ss) into seconds-within-year
yhms2sec    = compose(sum, StarMap(mul), Zip([86400, 3600, 60, 1]), Map(int))
# extract those values from an utctimetuple()
utsec_year  = compose(yhms2sec, GetA('tm_yday', 'tm_hour', 'tm_min', 'tm_sec'), Call('utctimetuple'))
# extract them from a VEX time stamp 
vextime2sec = compose(yhms2sec, Call('groups'), re.compile(r"^\d+y(\d+)d(\d+)h(\d+)m(\d+)s$").match,
                      partial(re.sub, r"[ \t\n]*", r""))
utcsec_now  = utsec_year( datetime.datetime.utcnow() )

###################################################
#       Supported recorders
###################################################

class Mark5C(object):
    __repr__ = method(const("Mark5C"))

class Mark6(object):
    __repr__ = method(const("Mark6"))

#############################################################################
#
#                      Commandline parsing
#
#############################################################################
class PrintHelp(argparse.Action):
    def __call__(self, the_parsert, *args):
        the_parsert.print_help() or sys.exit( 0 )

arg0_or_zero = choice(truth, itemgetter(0), const(0))
def usage(*args):
    # http://stackoverflow.com/a/1676860
    import pydoc, inspect
    # extract the documentation at the top of this module, put it through pydoc.pager and then exit :-)
    return compose(const(arg0_or_zero(args)), pydoc.pager, inspect.getcomments, itemgetter(__name__))(sys.modules)

class PrintUsage(argparse.Action):
    def __call__(self, the_parsert, *args):
        sys.exit( usage() )

# an action which (attempts to) map a recorder type string into an actual type
recorder_mapping  = {'mark5c':Mark5C, 'mark6':Mark6}
recorder_type     = compose(apply, choice(recorder_mapping.__contains__, recorder_mapping.__getitem__,
                            Error("Unknown recorder type {0}".format)), str.lower)


parsert = argparse.ArgumentParser(description="Transform VEX files to .snp/.prc", add_help=False)
parsert.add_argument('--help',   nargs=0, action=PrintHelp, help="Show this help message and exit succesfully")
parsert.add_argument('--usage',  nargs=0, action=PrintUsage, help="Show built-in usage")
parsert.add_argument('--debug',  dest='debug', action='store_true', default=False, 
                     help="Print debugging information")
parsert.add_argument('--version', action='version', version=version, help="Print current version and exit succesfully")
parsert.add_argument('--dest', dest='output_path', type=str, default="/usr2/sched",
                     help="Location where to store output .prc/.snp files")
parsert.add_argument('--force', dest='file_exists', action="store_const", const=const(False), default=os.path.isfile,
                     help="Overwrite existing output files (default: don't)")
parsert.add_argument('--station', dest='station', type=str, required=True,
                     help="The station two-letter-codefor which to generate the .prc/.snp files")
parsert.add_argument('--recorder', dest='recorder', type=recorder_type, default=None,
                     help="The recorder type (Mark5C, Mark6) to use")
parsert.add_argument('--ignore-utc', dest="utc_limit", default=utcsec_now, action="store_const", const=0,
                     help="Ignore current UTC time - i.e. just process all scans even when they cannot be observed anymore")
parsert.add_argument("vexfile", nargs='*', help="One or more vexfiles to process")

###################################
# Actually parse the command line #
###################################
userinput = parsert.parse_args()

# Take some actions based on what the user gave us (debug e.g.)
if userinput.debug:
    D  = MSG("DEBUG")
    DD = lambda y: MSG(y)
else:
    D  = identity
    DD = const(identity)
    def silent_except_hook(tp, val, tb):
        print(str(val))
    sys.excepthook = silent_except_hook

#################################################################################################
#
#                 Handle a single vex file
#
#################################################################################################
fileExists = choice(os.path.isfile, identity, compose(Raise, RuntimeError, partial(add, "File does not exist: ")))

# transform /path/to/file.vex => file
#  .split() => (/path/to, file.vex)
#  .splitext() => (file, vex)
vexName    = compose(GetN(0), os.path.splitext, GetN(1), os.path.split)

# input: vexfile name, output: functions generating the names of the output file(s) given a station
fn_func      = lambda ext: (lambda base: compose("{0}{{0}}.{1}".format(base.lower(), ext.lower()).format, str.lower))
add_prefix   = partial(os.path.join, userinput.output_path)
output_files = lambda vexobj, station: compose(DD("Output files"), Map(compose(add_prefix, ylppa(station))),
                                               Pam(*map(fn_func, ['snp', 'prc', 'lst'])), Slice(0,6),
                                               str.lower, next, Call('iterkeys'), GetN('EXPER'))(vexobj)

# Filter the given list-of-files using userinput.file_exists. Non-empty list raises an error.
ok_to_write  = compose(choice(truth,
                              compose(Raise, RuntimeError, "Output file(s) {0} exist. Use --force to forcibly overwrite".format),
                              identity),
                       list, Filter(userinput.file_exists))


###############################################################################
#
#                      Dealing with vex content
#
###############################################################################

# wrapper to turn opening a vex file into a context so 
# this works: 
#    with OpenVex(filename) as vexf: 
#        <stuff with vexf>
class OpenVex(object):
    def __init__(self, filename):
        self.filename = filename
    def __enter__(self):
        self.vex = Vex(self.filename)
        return self.vex
    def __exit__(self, e, t, f):
        return

vexyear     = compose(GetN(0), Map(int), Call('groups'),
                      re.compile(r"^(\d+)y\d+d\d+h\d+m\d+s$").match, partial(re.sub, r"[ \t\n]*", r""))

def s2v_r(acc, x):
    (whole, remain) = divmod(acc.time, x[0])
    acc.time_s     += x[1](whole)
    acc.time        = remain
    return acc
sec2vextime = compose(GetA('time_s'), AssertF(compose(not_, GetA('time')), "Non-integer second time stamp is unacceptable"),
                      Reduce(s2v_r, [(86400, "{0}d".format), (3600, "{0:02d}h".format),
                                     (60, "{0:02d}m".format), (1, "{0:02d}s".format)]),
                      lambda x: Type(time_s="", time=x))
intSec      = compose(int, str.strip, partial(re.sub, r"s(ec)?", r""))


class Scan(object):
    __slots__ = ['mode', 'label', 'nominal_start', 'source', 'offset', 'duration', 'year']

    # initialize from keywordargs
    def __init__(self, **kwargs):
        reduce(lambda acc, attr: setattr(acc, attr, kwargs.pop(attr, None)) or acc, Scan.__slots__, self)
        Assert(self.duration>self.offset, "Attempt to observe scan where data-good > scan duration")

    @property
    def start(self):
        return self.nominal_start + self.offset
    @property
    def end(self):
        return self.nominal_start + self.duration


def station_scan(station):
    # scan == (scanId, <vex scan obj>)
    def station_observes(scan):
        (scanId, scanObj) = scan
        #station=Eb:    0 sec:  620 sec:   42.961 GB:   :       : 0;
        #        0      1       2          3               4      5
        station_line      = filter(compose(partial(eq, station), GetN(0)), scanObj.getall('station'))
        station_line      = station_line[0] if station_line else None
        if not station_line:
            return None
        return Scan(mode=scanObj['mode'], nominal_start=vextime2sec(scanObj['start']),
                    source=scanObj['source'], offset=intSec(station_line[1]), label=scanId,
                    year=vexyear(scanObj['start']), duration=intSec(station_line[2]))
    return station_observes

# Filter the list of scans for the indicated station and also
# filter out the ones that are in the past
end_in_future     = compose(partial(lt, userinput.utc_limit), GetA('end'))
get_station_scans = lambda station: compose(Filter(end_in_future), Filter(truth), Map(station_scan(station)), Call('iteritems'), GetN('SCHED'))

# From a MODE extract the IF, FREQ, BBC, TRACKS, PHASE_CAL_DETECT for the requested station.
# In the VEX file these are ref lines so format is:
#   ref $REF = <defname> : station : station : ... ;
#   ref $REF = <defname> : station : station : ... ;
#
#   mode.iteritems() gives us a sequence of:
#      [ (REF-name, [<defname>, station, station, ...]),
#        (REF-name, [<defname>, station, station, ...], .. ]
# So we filter the required REF-name's that we need, keeping only the entry
# where the requested station is in the list of stations following the <defname>.
# 
# Eventually we produce a dict with entries like this:
#       {"mode": ("setupXX", <mode-for-station>)}
# 
#  where <mode-for-station> == { 'BBC': "defname>, 'IF': "defname", ... }


# extract <vexfile>['MODE'][mode] <object> and set <object>.mode = "mode"
get_mode         = lambda vexobject: lambda mode: compose(setattr_('mode', mode), GetN(mode), GetN('MODE'))(vexobject)
# set <mode object>.setup = "setupXX", auto-counting from 1
enumerate_setups = lambda mode, cnt=itertools.count(1): setattr_('setup', "setup{0:02d}".format(next(cnt)))(mode)
# Which ref lines we need and how to tell which one applies to a particular station
needed_refs      = set(['IF', 'FREQ', 'BBC', 'TRACKS', 'PHASE_CAL_DETECT'])
is_for_station   = lambda station  : lambda l: l[0] if station in l[1:] else None
refs_for_station = lambda st, modes: reduce(lambda acc, mode:
                                     acc.update( {mode.mode:(mode.setup,
                                                             compose(dict, Map(compose(tuple, Pam(GetN(0), compose(GetN(0), GetN(1))))),
                                                                     Filter(compose(is_for_station(st), GetN(1))),
                                                                     Filter(compose(needed_refs.__contains__, GetN(0))),
                                                                     list, Call('iteritems'))(mode)) } ) or acc, modes, dict())

###############################################################################
##    moving on to decoding
###############################################################################

mk_vex_lut = lambda sect, defname, key:compose(DD("VEX lut[{0}.{1}".format(sect,defname)), dict, Map(Pam(head, tail)),
                                               Call('getall', key), GetN(defname), GetN(sect))

# shorthands for converting vex file values to canonical things
fltMHz     = choice(truth, compose(float, str.strip, partial(re.compile(r'[ \t]*MHz').sub, "")), const(None))
sideband_  = { 'U': 'usb', 'L': 'lsb' }
canon_sb   = compose(sideband_.__getitem__, str.upper)
canon_pol  = str.lower
canon_if   = str.lower
pcal_state = choice(is_none, const("pcaloff"), const("pcalon"))
canon_pcal = choice(is_none, const("off"), int)
# there is a mapping of IF_A/B => input 0 and C/D to 1
inp_zero   = "AaBb"
inp_one    = "CcDd"
if_to_inp  = choice(inp_zero.__contains__, const(0),
                    choice(inp_one.__contains__, const(1),
                           Error("No known mapping for IF{0} to RDBE input".format)))

pfb_split  = compose(enumerate, Filter(truth), Partition(lambda x: x.sb == 'lsb'))
# group list of channels by their IF and return [(IF, <channels>), ...]
# Note: groupby() returns tuples with (key, <iterable>) but the <iterable> can be
#       used only once. So we transform that into a list
if_key     = GetA('abcd')
split_by_if= compose(Map(lambda t: (t[0], list(t[1]))), GroupBy(if_key), Sorted(key=if_key))
# given list of CHxx channel refs, sort numerically by xx
int_key    = lambda *args: compose(int, Call('group', 1), re.compile(*args).match)
int_sorted = lambda *args: Sorted(key=int_key(*args))
#chet's 'upper edge' table, modified to add 1024, leave out 528
# (verbatim from vex2snap.pl)
chet_fh    = [1024,1008,976,944,912,880,848,816,784,752,720,688,656,624,592,560];
lookup_fh  = choice(chet_fh.__contains__, chet_fh.index, Error("Unmapped PFB channel frequency {0}".format))

inputs     = lambda: (itertools.product( ["dbe0", "dbe1"], range(2) ))
concat     = Reduce(add)          # input: iterable-of-lists, output one list

# Post-process the iochannel assignments
def mk_ioch_(acc, item):
    # item = (dbe, <dict>)
    dbe, ch_dict = item
    cmd = "rdbe_cmd="+dbe+",5,dbe_ioch_assign=";
    # loop over the channels in vex order because that's
    # how they need to be written?
    for ch in sorted(ch_dict.iterkeys(), key=int_key("^CH(\d+)")):
        cmd += "{0}:{1}::".format( *ch_dict[ch] )
    cmd += ";"
    return acc.append( cmd ) or acc
mk_ioch = lambda l: reduce(mk_ioch_, l, list())

# input:  setup.dbes_used, which is: set( (<dbe>, <input>), ... )
# output: set of unique <dbe>'s 
get_dbes     = compose(set, Map(GetN(0)))
# From a dict {"mode":Setup(), ...}, extract the set of all dbe's used over all setups
get_all_dbes = compose(Reduce(set.union), Map(compose(get_dbes, GetA('dbes_used'))), Call('itervalues'))

###############################################################################
#
#  Process the channels based on deduced type of firmware
#  and generate the RDBE procedure
#
###############################################################################
def fqlist_pfb(setup):
    # put all channels of one kind of sideband in one DBE, filter out
    # ones that don't have channels and enumerate the resulting channel lists
    fqs            = list()
    los, rdbe_los  = (dict(), dict())
    clrs           = DDict(list)
    # Keep a mapping of DBE => [CHref => (inp, ch)] in order to be able 
    # to generate the correct "dbe_ioch_assign" command
    iochs          = DDict(dict)   # map (CHref) => (inp, ch)
    pcal_s         = set()    # set of pcal states, can assert we only have one
    rdbe_inp       = inputs() # allow us to loop over all inputs
    
    for IF, ch_list in split_by_if(setup.channels):
        # we could split it up in chunks of 16 channels and route the same IF
        # to multiple RDBE inputs but for now we don't
        Assert(len(ch_list)<=16, "Cannot do more than 16 channels per RDBE IF input")

        # assign those channels to the next available input
        (dbe, inp) = next(rdbe_inp)
        if dbe not in clrs:
            #clrs[dbe].append( "rdbe_person={dbe},pfb".format(dbe=dbe) )
            clrs[dbe].append( "rdbe_send={dbe},off".format(**locals()) )
            clrs[dbe].append( "rdbe_cmd={dbe},50,dbe_personality=pfbg:pfbg_1_4.bin".format(dbe=dbe) )
            clrs[dbe].append( "rdbefclr={dbe}".format(dbe=dbe) )
        # count channels per IF
        for (chan, ch) in enumerate(ch_list, start=1):
            # convert channel properties to stuff we need
            ch_frq = int(ch.freq - ch.lo)
            iif    = if_to_inp(ch.abcd)
            ich    = lookup_fh(abs(ch_frq))  # look up channel freq in table to find index
            setup.dbes_used.add( (dbe, iif) )
            # Get current pcal state
            pcal_s.add( pcal_state(ch.pcal) )
            # did we set the LO for this (IF,input)?
            loc    = "lo{ch.canon_if}".format( **locals() )
            if (loc, iif) not in los:
                los[(loc, iif)] = "lo="+loc+",{ch.lo:.2f},{ch.canon_if_sb},{ch.canon_pol}cp,{ch.canon_pcal}".format(**locals())
                rdbe_los[(loc, iif)] = "rdbe_if="+loc+",{ch.lo:.2f},{ch.canon_if_sb},{ch.canon_pol}cp,{dbe},if{iif}".format(**locals())
            # Append a line describing this channel
            fqs.append( "rdbef{ch.bbc:02d}={dbe},if{iif},{ch.freq:.2f},{ch.bw},{ch.canon_sb},{ch.canon_pol},{ich}".format(**locals()) )
            # Put it in the ioch mappings
            iochs[ dbe ][ ch.ch_ref ]= (iif, ich)

    # assert there's only one pcal state
    Assert(len(pcal_s)==1, "Inconsistent PCAL states - more than one found")

    # for all used dbes enable send again
    enable_send = reduce(lambda acc, x: acc.append("rdbe_send={0},on".format(x)) or acc, get_dbes(setup.dbes_used), list())
    # concatenate all commands - take care of re-ordering the "rdbefXX" commands by XX
    return [pcal_state(pcal_s.pop())] + los.values() + concat(clrs.values())+sorted(fqs, key=int_key(r"^rdbef(\d+)", re.I)) + \
           rdbe_los.values() + mk_ioch(iochs.iteritems()) + enable_send

# distribute the DDC channels over the RDBE inputs 
# according to vex2snap.pl
#   if dual pol 8 channel, send R to dbe0 and L to dbe1
# otherwise assign ch 0-3 to DBE0, 4-7 to DBE1
pol_key      = GetA('pol')
split_by_pol = compose(Map(lambda t: (t[0], list(t[1]))), GroupBy(pol_key), Sorted(key=pol_key))

# given: list of [(pol, [channels]), (pol, [channels])]
# return:  ( dual-pol <bool>,
#            total-nr-channels <int>,
#            each-pol-same-nr-channels <bool>,
#            max-nr-channels-per-pol <int> )
check_dual_p = compose(Pam(compose(partial(eq, 2), len), sum, all_equal, max), Map(compose(len, GetN(1))))
ddc_channels = lambda: (itertools.product( ["dbe0", "dbe1"], range(4) ))
invert_sb_   = {'l':'u', 'lsb':'usb', 'u':'l', 'usb':'lsb'}
invert_sb    = compose(choice(invert_sb_.__contains__, invert_sb_.__getitem__, Error("Unknown sideband {0}".format)), str.lower) 

# RDBE setting up DownConverters is tricky, must use first match in the tables.
# for upper side band           DDS freq       M  S  [M=Mode S=Sub]
usb_table    =[ lambda fq, bw:  (fq-512+bw/2,  1, 2) if fq<=(640-bw)   else None
              , lambda fq, bw:  (768-fq-bw/2,  0, 1) if fq<=(768-bw)   else None
              , lambda fq, bw:  (768-fq-bw/2,  0, 1) if fq<=(768-bw/2) else None
              , lambda fq, bw:  (fq+bw/2-768,  1, 1) if fq< (768)      else None
              , lambda fq, bw:  (fq-768+bw/2,  1, 1) if fq<=(896-bw)   else None
              , lambda fq, bw:  (1024-fq-bw/2, 0, 0) if fq<=(1024-bw)  else None]
# for lower side band           DDS freq       M  S  [M=Mode S=Sub]
lsb_table    =[ lambda fq, bw:  (1024-fq+bw/2, 1, 0) if fq>=(896+bw)   else None
              , lambda fq, bw:  (fq-768-bw/2,  0, 3) if fq>=(768+bw)   else None
              , lambda fq, bw:  (fq-768-bw/2,  0, 3) if fq>=(768+bw/2) else None
              , lambda fq, bw:  (768-fq+bw/2,  1, 3) if fq>=(768)      else None
              , lambda fq, bw:  (768-fq+bw/2,  1, 3) if fq>=(640+bw)   else None
              , lambda fq, bw:  (fq-512-bw/2,  0, 2) if fq>=(512+bw)   else None]

# This function executes the functions in the table selected by sideband and
# returns the first entry that is not None
get_dds_cfg = lambda sb, fq, bw: compose(next, partial(itertools.dropwhile, is_none),
                                         Map(lambda f: f(fq, bw)))(usb_table if sb in ['u', 'usb'] else lsb_table)

# input: dict of {<dc#> : <phys inp>, ... }
# produce string "dbe_xbar=<phys inp>:<phys inp>:<phys inp>[:<dummy entries up until DC07 imput>;"
#  sorted by <dc#>
mk_xbar_ = lambda tbl: "dbe_xbar="+":".join(map(str, getitem_(*sorted(tbl.keys()))(tbl)))+ ":".join(["2"]*(8-len(tbl)))+";"
# input: dict of { dbe : dc#-to-phys-input-mapping }
# output: list of [ "rdbe_cmd=dbe0,3,dbe_xbar=3:3:3:2:2:2:2:2;", ... ]
mk_xbar  = compose(Map(compose(Reduce(add), Pam(compose("rdbe_cmd={0},3,".format, GetN(0)), compose(mk_xbar_, GetN(1))))),
                   Call('iteritems'), DD("xbar-cfg"))
# input:  dict of { <dbe>: [0,2,4,..] } VDIF thread assignments
# output: [ "rdbe_cmd=<dbe>,3,dbe_vdif_threads_id=0,2,4;", ... ]
mk_vdif_ = lambda lst: "dbe_vdif_threads_id="+":".join(map(str, lst))+";"
mk_vdif  = compose(Map(compose(Reduce(add), Pam(compose("rdbe_cmd={0},3,".format, GetN(0)), compose(mk_vdif_, GetN(1))))),
                   Call('iteritems'), DD("vdif-thread-cfg"))

def fqlist_ddc(setup):
    # put all channels of one kind of sideband in one DBE, filter out
    # ones that don't have channels and enumerate the resulting channel lists
    dbes, fqs, dcs = (list(), list(), list())
    los, rdbe_los  = (dict(), dict())
    clrs           = DDict(list)
    vdif           = DDict(list)
    # Keep a mapping of channel  => (dbe, ch) in order to be able 
    # to generate the correct xbar commands and downconverter commands
    ch_assign      = dict()
    pcal_s         = set()    # set of pcal states, can assert we only have one
    xbar           = DDict(dict)
   
    # get list: [ (pol, [channels]), (pol, [channels]), ...]
    chans_by_pol   = split_by_pol(setup.channels)

    # for dual pol dual rdbe we require: total nr of channels > 4 and #-right-pol == #-left-pol
    (dual_pol, n_chan_tot, same_nch_pol, max_chan_pol) = check_dual_p( chans_by_pol )

    # some assertions never hurt
    Assert(n_chan_tot<=8, "DDC mode cannot support {0} channels, it is limited to <=8".format(n_chan_tot))
    # this constraint could be different between how flexible IFs can be routed to RDBE inputs
    Assert(max_chan_pol<=4, "DDC mode cannot support {0} channels / polarization, it is limited to <=4".format(max_chan_pol))

    # Assign channels to DBE inputs, based on what we seem to have found
    if dual_pol and same_nch_pol and n_chan_tot>4:
        # dual pol > 4 channels, assign each pol to one DBE 'r' => dbe0, 'l' => dbe1
        for pol, ch_list in chans_by_pol:
            dbe = "dbe0" if canon_pol(pol) == 'r' else "dbe1"
            # send all channels to this DBE
            for ich, ch in enumerate(ch_list):
                ch_assign[ ch ] = (dbe, ich)
    else:
        # Distribute the channels over the available DBE's and channels-within-DBE
        available_channels = ddc_channels()
        for ch in channels:
            ch_assign[ ch ] = next(available_channels)

    # Now that we've assigned channels, we can configure the downconverters,
    # the xbar and the VDIF thread assignment
    for ch, assign in ch_assign.iteritems():
        (dbe, ich) = assign
        # convert channel properties to stuff we need
        ch_frq     = int(ch.freq - ch.lo)
        iif        = if_to_inp(ch.abcd)
        setup.dbes_used.add((dbe, iif))
        # Get current pcal state
        pcal_s.add( pcal_state(ch.pcal) )
        # did we set the LO for this (IF,input)?
        loc    = "lo{ch.canon_if}".format( **locals() )
        if (loc, iif) not in los:
            los[(loc, iif)] = "lo="+loc+",{ch.lo:.2f},{ch.canon_if_sb},{ch.canon_pol}cp,{ch.canon_pcal}".format(**locals())
            rdbe_los[(loc, iif)] = "rdbe_if="+loc+",{ch.lo:.2f},{ch.canon_if_sb},{ch.canon_pol}cp,{dbe},if{iif}".format(**locals())
        # configure the downconverter
        decimation, rem = divmod(128, ch.bw)
        Assert(rem==0, "Channel bandwidth {0} not supported by DDC".format(ch.bw))
        # check for lower/upper side band
        sb = copy.deepcopy(ch.sb)
        if ch_frq<0:
            ch_frq = -ch_frq
            sb     = invert_sb(sb)
        sb = canon_sb(sb)
        # Append a line describing this channel
        # Note: the last digit is the channel and all DDC channels get
        #       stuffed into IF0. rdbe_tsys.c expects this.
        fqs.append( "rdbef{ch.bbc:02d}={dbe},if{iif},{ch.freq:.2f},{ch.bw},{sb},{ch.canon_pol},0".format(**locals()) )
        # Get the downconverter config
        (dds_freq, mode, sub) = get_dds_cfg(sb, ch_frq, ch.bw)
        dcs.append( "rdbe_dc_cfg={dbe},{ich}:{decimation}:{dds_freq:.2f}:{mode};".format(**locals()) )
        # and the xbar
        xbar[ dbe ][ ich ] = sub + iif*4
        vdif[ dbe ].append( ch.bbc-1 )

    # add commands to load personality and clear
    for dbe in get_dbes(setup.dbes_used):
        clrs[dbe].append( "rdbe_send={dbe},off".format(**locals()) )
        clrs[dbe].append( "rdbe_cmd={dbe},50,dbe_personality=ddc:ddc_1601583.bin".format(dbe=dbe) )
        clrs[dbe].append( "rdbefclr={dbe}".format(dbe=dbe) )

    # for all used dbes enable send again
    enable_send = reduce(lambda acc, x: acc.append("rdbe_send={0},on".format(x)) or acc, get_dbes(setup.dbes_used), list())

    # assert there's only one pcal state
    Assert(len(pcal_s)==1, "Inconsistent PCAL states - more than one found")
    return [pcal_state(pcal_s.pop())] + los.values() + concat(clrs.values()) + sorted(fqs, key=int_key(r"^rdbef(\d+)", re.I)) +\
           rdbe_los.values() + dcs + mk_xbar(xbar) + mk_vdif(vdif) + enable_send


# lookup table
fqlist_fn   = {'PFB': fqlist_pfb, 'DDC4': fqlist_ddc, 'DDC8': fqlist_ddc }
make_fqlist = choice(fqlist_fn.__contains__, fqlist_fn.__getitem__, 
                     compose(Raise, RuntimeError, "No make_fqlist for firmware {0}".format))


#################################################
# describe a setup from the VEX file
#################################################
class Setup(object):
    __slots__ = ['setup', 'mode', 'channels', 'track_frame_format', 'dbes_used']

    def __init__(self, **kwargs):
        reduce(lambda acc, attr: setattr(acc, attr, kwargs.pop(attr, None)) or acc, Setup.__slots__, self)
        self.dbes_used = set()

    def __repr__(self):
        return "Setup: {0.setup} [{0.mode}] {0.datarate}Mbps {0.track_frame_format} ".format(self) + self.firmware + \
               "\n\t".join([""]+map(repr, [] if not self.channels else self.channels))

    @property
    def firmware(self):
        if self.channels is None:
            return None
        return "PFB" if len(self.channels)>8 else ("DDC4" if len(self.channels)<=4 else "DDC8")

    @property
    def datarate(self):
        # sum all bandwidths (units in MHz), multiply by 2 on account of Nyquist
        return 2 * int(sum(map(GetA('bw'), [] if self.channels is None else self.channels)))

    @property
    def procedures(self):
        Assert(self.channels is not None, "No channels defined for setup {0}".format(self.setup))
        # generate the procedure text
        return [Procedure(self.setup, make_fqlist(self.firmware)(self))]


class Channel(object):
    __slots__ = ['bbc', 'abcd', 'pol', 'lo', 'sb', 'if_sb', 'pcal', 'bw', 'freq', 'ch_ref']

    def __init__(self, **kwargs):
        reduce(lambda acc, attr: setattr(acc, attr, kwargs.pop(attr, None)) or acc, Channel.__slots__, self)

    @property
    def canon_pcal(self):
        return canon_pcal(self.pcal)
    @property
    def canon_sb(self):
        return canon_sb(self.sb)
    @property
    def canon_if_sb(self):
        return canon_sb(self.if_sb)
    @property
    def canon_if(self):
        return canon_if(self.abcd)
    @property
    def canon_pol(self):
        return canon_pol(self.pol)
    @property
    def pcal_state(self):
        return pcal_state(self.pcal)

    __hash__ = method(GetA('bbc'))
    __repr__ = method("BBC{0.bbc:02d}: {0.bw:.2f}MHz@{0.freq:.2f} [LO={0.lo:.2f}MHz] {0.sb} {0.pol} pcal:{0.pcal}".format)


####################################################
#  A snap procedure
####################################################
lineify = choice(reorder_args(isinstance, [1,0], list), identity, mk_lines)

class Procedure(object):
    _defaults = { 'initial_newline': '\n' }
    def __init__(self, name, init_list=None, **kwargs):
        # at most 12 characters in procedure name
        Assert(len(name)<=12, "SNAP procedure name '{0}' is longer than 12 characters".format(name))
        # initialize defaults which could be overriden through kwargs
        reduce(lambda acc, attr: setattr(acc, attr, kwargs.pop(attr, Procedure._defaults.get(attr, None))) or acc,
               Procedure._defaults.keys(), self)
        self.name    = name
        self.lines   = copy.deepcopy(init_list if init_list is not None else list())

    def append(self, line):
        self.lines.extend(lineify(line))
        return self

    def __hash__(self):
        return hash(self.name)

    def __str__(self):
        return "{0}define  {1: <12s} 00000000000x\n".format(self.initial_newline, self.name) + "\n".join(self.lines)+"\nenddef"

# input: - ("mode", ("setupXX", { 'BBC': "BBC-def", 'IF': "IF-def", ... ) 
#        - vex object
# transform to:
#          ("mode", Setup(setup="setupXX", procedure="define setupXX 0000000x\n .... enddef\n", firmware="..."))
def resolve_mode(vexobj):
    def do_resolve(acc, mode):
        # destructure the mode "(key, value)" item, where value = "(setup, {})"
        (modename, (setupname, setup)) = mode

        # Transform the BBC_assign entries into lookuptable {BBCref: (BBCnum, IFref), ...}
        bbc_lut = mk_vex_lut('BBC', setup['BBC'], 'BBC_assign')(vexobj)
        if_lut  = mk_vex_lut('IF' , setup['IF'] , 'if_def')(vexobj)

        # Can already construct the actual setup object
        nSetup = Setup(mode=modename, setup=setupname, channels=list(),
                       track_frame_format=vexobj['TRACKS'][setup['TRACKS']]['track_frame_format'])

        # Loop over all defined frequency channels, collect important frequency, lo info
        for fqchan in vexobj['FREQ'][setup['FREQ']].getall('chan_def'):
            (_, ch_freq, sb, bw, ch_ref, bbc_ref, nix) = fqchan
            (bbc_num, if_ref)                     = bbc_lut[ bbc_ref ]
            (ABCD, if_pol, if_lo, if_sb, if_pcal) = if_lut[ if_ref ]
            nSetup.channels.append( D(Channel(bbc=int(bbc_num), abcd=ABCD, pol=if_pol, lo=fltMHz(if_lo), ch_ref=ch_ref,
                                              sb=sb, if_sb=if_sb, pcal=fltMHz(if_pcal), bw=int(fltMHz(bw)), freq=fltMHz(ch_freq))) )

        # insert new setup into accumulator
        #print(nSetup.procedure)
        return setitem_(modename, nSetup)(acc)
    return do_resolve


# basic procedures
get_EXPER = compose(str.upper, GetN('exper_name'), GetN(1), next, Call('iteritems'), GetN('EXPER'))
mk_lines  = compose(Filter(truth), Map(str.strip), Call('split', '\n'))

def proc_library(vexfile, userinp):
    return Procedure("proc_library", mk_lines(
    """ " {exper} {STATION}_RDBE {station}\n
     " vex2snap/Python version 2019 by Harro Verkouter, JIVE\n
     " based on vex2snap version 2014_nov_06 by DG and UB, MPIfR\n
     "< RDBE  rack><{recorder: <10s}recorder 1>< None    recorder 2>""".format(
             exper=get_EXPER(vexfile), station=userinput.station, STATION=userinput.station.upper(),
             recorder = str(userinput.recorder))), initial_newline="")

def exper_init(vexfile, userinp):
    return Procedure("exper_initi", mk_lines("proc_library\nsched_initi\n"))

def sched_init(vexfile, userinp):
    return Procedure("sched_initi")

standard_procedures = Pam(proc_library, exper_init, sched_init)

def process_setup(acc, setup):
    return reduce(lambda a, p: (a[p].append(p.lines) or a) if p in a else setitem_(p, p)(a), setup.procedures, acc)


# ordered dict with a tiny twist -
# the key will always be hash(key) such that 
# the elements can be indexed by Procedure() or by "name" -
# hash(Procedure) returns hash(self.name)
class MOrderedDict(collections.OrderedDict):
    def __setitem__(self, key, *args, **kwargs):
        return collections.OrderedDict.__setitem__(self, hash(key), *args, **kwargs)

    def __getitem__(self, key, *args, **kwargs):
        return collections.OrderedDict.__getitem__(self, hash(key), *args, **kwargs)

    def __delitem__(self, key, *args, **kwargs):
        return collections.OrderedDict.__delitem__(self, hash(key), *args, **kwargs)

# input:  dict{ "mode":Setup(), "mode":Setup(), ... }
# output: [Setup(), Setup(), ...] ordered by setup name "setup01", "setup02", ...
ordered_setups = compose(Sorted(key=compose(int_key("^setup(\d+)"), GetA('setup'))), Map(GetN(1)), Call('iteritems'))

#############################################################
#        do the work of processing the vex file
#############################################################
def process_vex(vexfile):
    with OpenVex(vexfile) as vexf:
        # Generate the output file names: destination/<exper><station>.{prc, snp, lst}
        files = output_files(vexf, userinput.station)
        # check if they exist and if so if ok to overwrite
        ok_to_write(files)

        # figure out which scans the station should observe
        # we do not extract the scan object(s) from the vexfile yet because
        # we need to retain the order of the scans (if we created a dict { "scanLabel":<scanObject> }
        # we could loose the order of scan label. There is no guarantee scan labels contain any useful information.
        scans  = get_station_scans(userinput.station)( vexf )

        Assert(scans, "The station '{0}' does not observe any of the scans".format(userinput.station))

        # Convert all mode names to a dict of {"mode", ("setupXX", {'BBC': <BBC-defname>, 'IF': <IF-defname>, ..}), ... }
        # with the defnames appropriate for the selected station
        modes  = compose(partial(refs_for_station, userinput.station), Map(enumerate_setups), Map(get_mode(vexf)),
                         Call('iterkeys'), GetN('MODE'))(vexf)

        # Transform that dict to { "mode": Setup(...), "mode":Setup(...), ... }
        setups = reduce(resolve_mode(vexf), modes.iteritems(), dict())

        # We want the procedures to be ordered - at least some of them
        procedures = MOrderedDict()#collections.OrderedDict()

        for proc in standard_procedures(vexf, userinput):
            procedures[proc] = proc
        
        # Now go over the setups - each may yield a list of (new) procedures they have 
        # or existing procedures they have to add stuff to
        # Note: setups = { "mode":Setup(), ... }
        #  But: we want the setups ordered by "setup01", "setup02", ...
        #   So: extract all Setup() objects and sort by name
        procedures = reduce(process_setup, ordered_setups(setups), procedures)

        # Now that all setups (and thus modes) have been generated,
        # we can extract the set of all dbe's ever used in all setups
        # so we can properly add initialization commands
        #for cmds in []:
        #    procedures
        for dbe in get_all_dbes( setups ):
            procedures["sched_initi"].append( "rdbe_command={dbe},3,dbe_data_send=on;\nrdbe_time={dbe},3".format(**locals()) )

        procedures["sched_initi"].append( "!+1s\ngetgps\n!+1s\nready_disk" )

        # todo: 
        # procedure collect - tsys
        #           start   - initiate collect every 10s
        #           preob   - ifread/dbe_quanttize_hold_set
        #           setupN  - recorder config?  


        # produce .snp file with all scans in

        #print("Scans: ", Map(GetA('label'))(scans))
        #print("Setups:", setups)
        #print("Modes: ", modes)
        #print("Recorder:", userinput.recorder)
        print("Procedures:")
        for p in procedures.values():
            sys.stdout.write(str(p))
    return None

# main loop: iterate over all command line arguments
main = Map(compose(process_vex, MSG("Start processing")))

main(userinput.vexfile)
